<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>COOKuP 3D Editor - GLB Support</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background: #1a1a1a;
      color: #fff;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100vh;
    }

.panel {
  position: fixed;
  background: rgba(30, 30, 30, 0.95);
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(10px);
  max-height: 80vh;
  overflow-y: auto;
  z-index: 1000;
  cursor: move;
  /* Add cursor indicator */
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  cursor: grab;
  user-select: none;
  padding: 4px;
  border-radius: 4px;
  transition: background 0.2s;
}

.panel-header:hover {
  background: rgba(255, 255, 255, 0.05);
}

.panel-header:active {
  cursor: grabbing;
}

.panel.dragging {
  opacity: 0.9;
  cursor: grabbing;
}

    .panel-header h3 {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
    }

    .toggle-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 18px;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
    }

    .panel-content {
      max-height: 400px;
      overflow-y: auto;
      transition: max-height 0.3s ease, opacity 0.3s ease;
    }

    .panel-content.collapsed {
      max-height: 0;
      opacity: 0;
      overflow: hidden;
    }

    .panel.collapsed {
      padding-bottom: 8px;
    }

    #upload-container {
      top: 10px;
      left: 10px;
      width: 280px;
    }

    #controls {
      top: 10px;
      right: 10px;
      width: 200px;
    }

    #object-list {
      bottom: 10px;
      left: 10px;
      width: 280px;
    }

    #texture-controls {
      top: 200px;
      left: 10px;
      width: 280px;
    }

    #bone-controls {
      bottom: 80px;
      right: 10px;
      width: 280px;
      width: 100px;
    }

    #save-load-controls {
      top: 100px;
      left: 10px;
      width: 280px;
    }

    button {
      background: #3a3a3a;
      border: 1px solid #555;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
      width: 100%;
      margin: 4px 0;
    }

    button:hover {
      background: #4a4a4a;
      border-color: #666;
    }

    button:active {
      transform: scale(0.98);
    }

    button.active {
      background: #4CAF50;
      border-color: #4CAF50;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .button-row {
      display: flex;
      gap: 4px;
    }

    .button-row button {
      flex: 1;
    }

    input[type="file"] {
      display: none;
    }

    .object-item, .bone-item {
      background: #2a2a2a;
      padding: 8px;
      margin: 4px 0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .object-item:hover, .bone-item:hover {
      background: #3a3a3a;
    }

    .object-item.selected, .bone-item.selected {
      background: #4CAF50;
      color: white;
    }

    .object-item button {
      background: #d32f2f;
      border: none;
      color: white;
      padding: 2px 8px;
      margin: 0;
      font-size: 16px;
      font-weight: bold;
      width: auto;
    }

    .object-item button:hover {
      background: #b71c1c;
    }

    .slider-group {
      margin: 8px 0;
    }

    .slider-group label {
      display: block;
      font-size: 11px;
      margin-bottom: 4px;
      color: #ccc;
    }

    input[type="range"] {
      width: 100%;
      margin: 4px 0;
    }

    .value-display {
      display: inline-block;
      font-size: 11px;
      color: #4CAF50;
      margin-left: 8px;
    }

    #bone-transform-controls {
      margin-top: 8px;
    }

    #selected-bone-name {
      font-size: 12px;
      color: #4CAF50;
      margin-bottom: 8px;
    }

    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    ::-webkit-scrollbar-thumb {
      background: #4a4a4a;
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #5a5a5a;
    }

    .info-text {
      font-size: 10px;
      color: #888;
      margin-top: 4px;
      font-style: italic;
    }
    
  /* ============= PS2 ANALOG CONTROLLER STYLES ============= */

.ps2-controller {
  background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%);
  border: 3px solid #444;
  border-radius: 15px;
  padding: 20px;
  box-shadow: 
    0 8px 16px rgba(0,0,0,0.6),
    inset 0 2px 4px rgba(255,255,255,0.1);
}

.ps2-header {
  text-align: center;
  color: #00ff88;
  font-weight: bold;
  font-size: 14px;
  margin-bottom: 20px;
  text-shadow: 0 0 10px rgba(0,255,136,0.5);
  letter-spacing: 1px;
}

.ps2-sticks-container {
  display: flex;
  justify-content: space-around;
  gap: 20px;
  margin-bottom: 20px;
}

.ps2-analog-stick-wrapper {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.ps2-stick-label {
  font-size: 10px;
  color: #888;
  margin-bottom: 8px;
  font-weight: bold;
  letter-spacing: 0.5px;
}

.ps2-analog-stick {
  width: 120px;
  height: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.ps2-stick-base {
  position: relative;
  width: 100px;
  height: 100px;
  background: radial-gradient(circle, #1a1a1a 0%, #0a0a0a 100%);
  border-radius: 50%;
  border: 4px solid #333;
  box-shadow: 
    inset 0 4px 8px rgba(0,0,0,0.8),
    0 4px 8px rgba(0,0,0,0.5);
  overflow: visible;
}

.ps2-stick-thumb {
  position: absolute;
  width: 45px;
  height: 45px;
  background: radial-gradient(circle at 30% 30%, #555, #222);
  border-radius: 50%;
  border: 3px solid #444;
  box-shadow: 
    0 4px 8px rgba(0,0,0,0.6),
    inset 0 2px 4px rgba(255,255,255,0.2);
  cursor: grab;
  transition: box-shadow 0.1s;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  align-items: center;
  justify-content: center;
}

.ps2-stick-thumb:hover {
  box-shadow: 
    0 4px 12px rgba(0,255,136,0.4),
    inset 0 2px 4px rgba(255,255,255,0.3);
  border-color: #00ff88;
}

.ps2-stick-thumb:active {
  cursor: grabbing;
  box-shadow: 
    0 2px 6px rgba(0,255,136,0.6),
    inset 0 2px 4px rgba(0,0,0,0.5);
}

.ps2-stick-dot {
  width: 8px;
  height: 8px;
  background: #00ff88;
  border-radius: 50%;
  box-shadow: 0 0 8px rgba(0,255,136,0.8);
}

.ps2-crosshair {
  position: absolute;
  background: rgba(255,255,255,0.1);
}

.ps2-crosshair-h {
  width: 100%;
  height: 1px;
  top: 50%;
  left: 0;
  transform: translateY(-50%);
}

.ps2-crosshair-v {
  width: 1px;
  height: 100%;
  left: 50%;
  top: 0;
  transform: translateX(-50%);
}

.ps2-stick-axes {
  margin-top: 10px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  font-size: 10px;
  color: #888;
  text-align: center;
}

.ps2-stick-axes span {
  display: block;
}

#rot-y-display,
#rot-x-display,
#rot-z-display {
  color: #00ff88;
  font-weight: bold;
  font-family: 'Courier New', monospace;
}

.ps2-reset-btn {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
  border: 2px solid #ff6666;
  border-radius: 8px;
  color: white;
  font-size: 12px;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0,0,0,0.4);
  transition: all 0.2s;
  letter-spacing: 1px;
}

.ps2-reset-btn:hover {
  background: linear-gradient(135deg, #ff6666 0%, #ff0000 100%);
  box-shadow: 0 6px 12px rgba(255,0,0,0.4);
  transform: translateY(-2px);
}

.ps2-reset-btn:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px rgba(0,0,0,0.4);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .ps2-sticks-container {
    flex-direction: column;
    gap: 30px;
  }
  
  .ps2-analog-stick {
    width: 140px;
    height: 140px;
  }
  
  .ps2-stick-base {
    width: 110px;
    height: 110px;
  }
}

  </style>
</head>
<body>

<input type="file" id="file-input" multiple>
<input type="file" id="ground-texture-input" accept="image/*">
<input type="file" id="sky-texture-input" accept="image/*">
<input type="file" id="extra-texture-input" accept="image/*" multiple>
<input type="file" id="load-scene-input" accept=".glb">
<!-- Add this input near your other file inputs at the top -->
<input type="file" id="hair-texture-input" accept="image/*" style="display: none;">

<!-- Upload Panel -->
<div class="panel" id="upload-container">
  <div class="panel-header" onclick="togglePanel('upload-container')">
    <h3>üìÅ Upload Models</h3>
    <span class="toggle-btn">‚àí</span>
  </div>
  <div class="panel-content">
    <button onclick="document.getElementById('file-input').click()">
      Upload 3D Model
    </button>
    <p class="info-text">Supports: FBX, STL, GLTF, GLB, OBJ</p>
  </div>
</div>

<!-- Transform Controls Panel -->
<div class="panel" id="controls">
  <div class="panel-header" onclick="togglePanel('controls')">
    <h3>üéÆ Transform</h3>
    <span class="toggle-btn">‚àí</span>
  </div>
  <div class="panel-content">
    <div class="button-row">
      <button id="translate-btn" class="active">Move</button>
      <button id="rotate-btn">Rotate</button>
      <button id="scale-btn">Scale</button>
    </div>
    <div class="button-row">
      <button id="lock-btn">Lock</button>
      <button id="unlock-btn">Unlock</button>
    </div>
    <div class="button-row">
      <button id="duplicate-btn">Duplicate</button>
      <button id="focus-btn">Focus</button>
    </div>
    <button id="delete-btn">Delete Selected</button>
    <button id="clear-btn">Clear All</button>
    <div class="button-row" style="margin-top: 8px;">
      <button id="undo-btn" disabled>‚Ü∂ Undo</button>
      <button id="redo-btn" disabled>‚Ü∑ Redo</button>
    </div>
  </div>
</div>

<!-- Object List Panel -->
<div class="panel" id="object-list">
  <div class="panel-header" onclick="togglePanel('object-list')">
    <h3>üì¶ Objects</h3>
    <span class="toggle-btn">‚àí</span>
  </div>
  <div class="panel-content">
    <div id="objects-container">
      <p style="font-size: 11px; color: #666;">No objects loaded</p>
    </div>
    <h4 style="font-size: 12px; margin-top: 12px; margin-bottom: 4px;">üñºÔ∏è Texture Planes</h4>
    <button onclick="document.getElementById('extra-texture-input').click()">
      Add Texture Plane
    </button>
    <div id="texture-planes-container" style="margin-top: 8px;">
      <p style="font-size: 11px; color: #666;">No texture planes</p>
    </div>
  </div>
</div>

<!-- Texture Controls Panel -->
<div class="panel" id="texture-controls">
  <div class="panel-header" onclick="togglePanel('texture-controls')">
    <h3>üåç Environment</h3>
    <span class="toggle-btn">‚àí</span>
  </div>
  <div class="panel-content">
    <button onclick="document.getElementById('ground-texture-input').click()">
      Ground Texture
    </button>
    <div class="slider-group">
      <label>Ground Tiling: <span class="value-display" id="ground-tile-value">10.0x</span></label>
      <input type="range" id="ground-tile-slider" min="1" max="50" step="0.5" value="10">
    </div>
    <button id="remove-ground-texture">Remove Ground</button>
    <button onclick="document.getElementById('sky-texture-input').click()" style="margin-top: 8px;">
      Sky Texture
    </button>
    <button id="toggle-sky-sphere">Toggle Sky Sphere</button>
    <button id="remove-sky-texture">Remove Sky</button>
    <button id="toggle-grid" style="margin-top: 8px;">Toggle Grid</button>
  </div>
</div>
<!-- Save/Load Panel -->
<div class="panel" id="save-load-controls">
  <div class="panel-header" onclick="togglePanel('save-load-controls')">
    <h3>üíæ Save/Load Scene</h3>
    <span class="toggle-btn">‚àí</span>
  </div>
  <div class="panel-content">
    <button id="save-scene-btn">üíæ Save Scene (GLB)</button>
    <button onclick="document.getElementById('load-scene-input').click()">
      üìÇ Load Scene (GLB)
    </button>
    <p class="info-text">GLB format preserves all models, textures, and transforms</p>
  </div>
</div>
<!-- Bone Controls Panel -->
<div id="bone-controls" class="panel">
  <div class="panel-header">
    <h2>ü¶¥ Bone Controls</h2>
    <button class="toggle-btn" onclick="togglePanel('bone-controls')">‚àí</button>
  </div>
  <div class="panel-content">
    <div id="bone-list" style="max-height: 150px; overflow-y: auto; margin-bottom: 15px;">
      <p style="font-size: 11px; color: #666;">No bones detected</p>
    </div>
    
    <button id="toggle-bones-btn" style="width: 100%; padding: 8px; margin-bottom: 8px; background: #555; border: none; border-radius: 4px; color: white; font-size: 12px; cursor: pointer;">
      Show Bones
    </button>
    
    <button id="toggle-bone-helpers-btn" style="width: 100%; padding: 8px; background: #555; border: none; border-radius: 4px; color: white; font-size: 12px; cursor: pointer;">
      Show Helpers
    </button>
    
<!-- Replace the entire PS2 controller div with this: -->
<div id="bone-transform-controls" style="display: none; margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
  <h3 style="margin: 0 0 15px 0; font-size: 13px; color: #4CAF50; text-align: center;">
    Selected: <span id="selected-bone-name">None</span>
  </h3>
  
  <div class="slider-group">
    <label>Rotation X: <span class="value-display" id="bone-rot-x-value">0¬∞</span></label>
    <input type="range" id="bone-rot-x" min="-360" max="360" step="1" value="0">
  </div>
  
  <div class="slider-group">
    <label>Rotation Y: <span class="value-display" id="bone-rot-y-value">0¬∞</span></label>
    <input type="range" id="bone-rot-y" min="-360" max="360" step="1" value="0">
  </div>
  
  <div class="slider-group">
    <label>Rotation Z: <span class="value-display" id="bone-rot-z-value">0¬∞</span></label>
    <input type="range" id="bone-rot-z" min="-360" max="360" step="1" value="0">
  </div>
  <!-- Add this button to your bone-controls panel -->
<button id="toggle-bone-vis-btn" onclick="window.toggleBoneVisualization()" 
        style="width: 100%; margin-top: 5px; background: #555; padding: 8px;">
  Show Bone Geometry
</button>

  <button id="reset-bone-btn" style="width: 100%; padding: 10px; margin-top: 10px; background: #f44336; border: none; border-radius: 4px; color: white; cursor: pointer;">
    Reset Bone Rotation
  </button>
</div>

        
        <!-- Reset Button -->
        <button id="reset-bone-btn" class="ps2-reset-btn">
          ‚Ü∫ RESET ALL ROTATIONS
        </button>
      </div>
    </div>
  </div>
</div>

// Add this to your HTML inside the body, after the bone-controls panel:

<!-- Primitives Panel -->
<div class="panel" id="primitives-panel" style="top: 400px; left: 10px; width: 280px;">
  <div class="panel-header" onclick="togglePanel('primitives-panel')">
    <h3>üìê Add Primitives</h3>
    <span class="toggle-btn">‚àí</span>
  </div>
  <div class="panel-content">
    <h4 style="font-size: 12px; margin-bottom: 8px;">Basic Shapes</h4>
    <button onclick="window.addPrimitive('plane')">Add Plane</button>
    <button onclick="window.addPrimitive('cube')">Add Cube</button>
    <button onclick="window.addPrimitive('sphere')">Add Sphere</button>
    <button onclick="window.addPrimitive('cylinder')">Add Cylinder</button>
    <button onclick="window.addPrimitive('cone')">Add Cone</button>
    <button onclick="window.addPrimitive('torus')">Add Torus</button>
    <button onclick="window.addPrimitive('ring')">Add Ring</button>
    
    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">Selected Object</h4>
    <button onclick="window.applyTextureToSelected()">Apply Texture</button>
    <button onclick="window.changePrimitiveColor()">Change Color</button>
    
    <div class="slider-group">
      <label>Metalness: <span class="value-display" id="metalness-value">0.0</span></label>
      <input type="range" id="metalness-slider" min="0" max="1" step="0.1" value="0">
    </div>
    
    <div class="slider-group">
      <label>Roughness: <span class="value-display" id="roughness-value">0.7</span></label>
      <input type="range" id="roughness-slider" min="0" max="1" step="0.1" value="0.7">
    </div>
    
    <div class="slider-group">
      <label>Opacity: <span class="value-display" id="opacity-value">1.0</span></label>
      <input type="range" id="opacity-slider" min="0" max="1" step="0.1" value="1.0">
    </div>
  </div>
</div>

<!-- Update the terrain panel with new features -->
<div class="panel" id="terrain-panel" style="top: 30px; left: 10px; width: 280px;">
  <div class="panel-header" onclick="togglePanel('terrain-panel')">
    <h3>üèîÔ∏è Terrain Editor</h3>
    <span class="toggle-btn">‚àí</span>
  </div>
  


  <div class="panel-content">
    <h4 style="font-size: 12px; margin-bottom: 8px;">Terrain Type</h4>
    <button id="hills-mode-btn" onclick="window.setTerrainMode('hills')">Mountain Hills</button>
    <button id="spikes-mode-btn" onclick="window.setTerrainMode('spikes')">Grass Spikes</button>
    <button id="smooth-mode-btn" onclick="window.setTerrainMode('smooth')">Smooth Terrain</button>
    <button id="canyon-mode-btn" onclick="window.setTerrainMode('canyon')">Canyons</button>
    <!-- Add this section after the terrain type buttons -->
<div id="spike-styles-section" style="margin-top: 12px;">
  <h4 style="font-size: 12px; margin-bottom: 8px;">üåæ Spike Style (when Grass Spikes selected)</h4>
  <button id="blades-style-btn" onclick="window.setSpikeStyle('blades')" class="active">Thin Blades</button>
  <button id="needles-style-btn" onclick="window.setSpikeStyle('needles')">Sharp Needles</button>
  <button id="clusters-style-btn" onclick="window.setSpikeStyle('clusters')">Grass Clusters</button>
  <button id="crystals-style-btn" onclick="window.setSpikeStyle('crystals')">Crystal Spikes</button>
</div>

    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">Terrain Settings</h4>
    
    <div class="slider-group">
      <label>Height: <span class="value-display" id="terrain-height-value">2.0</span></label>
      <input type="range" id="terrain-height-slider" min="0" max="10" step="0.1" value="2">
    </div>
    
    <div class="slider-group">
      <label>Density: <span class="value-display" id="terrain-density-value">5</span></label>
      <input type="range" id="terrain-density-slider" min="1" max="20" step="1" value="5">
    </div>
    
    <div class="slider-group">
      <label>Roughness: <span class="value-display" id="terrain-roughness-value">0.5</span></label>
      <input type="range" id="terrain-roughness-slider" min="0" max="1" step="0.1" value="0.5">
    </div>
    
    <div class="slider-group">
      <label>Ground Size: <span class="value-display" id="ground-size-value">200</span></label>
      <input type="range" id="ground-size-slider" min="50" max="1000" step="50" value="200">
    </div>
    
    <div class="button-row" style="margin-top: 12px;">
      <button id="apply-terrain-btn" onclick="window.applyTerrain()">Apply Terrain</button>
      <button id="reset-terrain-btn" onclick="window.resetTerrain()">Reset Flat</button>
    </div>
    
    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">Sculpt Mode</h4>
    <button id="toggle-paint-mode-btn" onclick="window.togglePaintMode()">Enable Sculpt Mode</button>
    <p class="info-text">Click and drag on ground to sculpt terrain</p>
    
    <div class="slider-group">
      <label>Brush Size: <span class="value-display" id="brush-size-value">5.0</span></label>
      <input type="range" id="brush-size-slider" min="0.5" max="20" step="0.5" value="5">
    </div>
    
    <div class="slider-group">
      <label>Brush Strength: <span class="value-display" id="brush-strength-value">0.5</span></label>
      <input type="range" id="brush-strength-slider" min="0.1" max="2" step="0.1" value="0.5">
    </div>
    
    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">üé® Texture Painting</h4>
    <button onclick="document.getElementById('paint-texture-1-input').click()">Load Texture 1 (Red)</button>
    <button onclick="document.getElementById('paint-texture-2-input').click()">Load Texture 2 (Green)</button>
    <button onclick="document.getElementById('paint-texture-3-input').click()">Load Texture 3 (Blue)</button>
    
    <div id="texture-previews" style="display: flex; gap: 4px; margin: 8px 0;">
      <div id="preview-1" style="width: 50px; height: 50px; background: #ff4444; border: 2px solid #666; border-radius: 4px;"></div>
      <div id="preview-2" style="width: 50px; height: 50px; background: #44ff44; border: 2px solid #666; border-radius: 4px;"></div>
      <div id="preview-3" style="width: 50px; height: 50px; background: #4444ff; border: 2px solid #666; border-radius: 4px;"></div>
    </div>
    
    <button id="toggle-texture-paint-btn" onclick="window.toggleTexturePaintMode()">Enable Texture Paint</button>
    <p class="info-text">Paint textures directly on terrain</p>
    
    <div class="button-row" style="margin-top: 8px;">
      <button id="texture-1-btn" onclick="window.selectPaintTexture(1)" class="active">Texture 1</button>
      <button id="texture-2-btn" onclick="window.selectPaintTexture(2)">Texture 2</button>
      <button id="texture-3-btn" onclick="window.selectPaintTexture(3)">Texture 3</button>
    </div>
    
    <div class="slider-group">
      <label>Paint Brush Size: <span class="value-display" id="paint-brush-size-value">3.0</span></label>
      <input type="range" id="paint-brush-size-slider" min="0.5" max="15" step="0.5" value="3">
    </div>
    
    <div class="slider-group">
      <label>Texture Tiling: <span class="value-display" id="texture-tiling-value">10</span></label>
      <input type="range" id="texture-tiling-slider" min="1" max="50" step="1" value="10">
    </div>
  </div>
</div>

<!-- Hair Particle System Panel -->
<div class="panel" id="hair-particle-panel" style="top: 400px; right: 10px; width: 300px;">
  <div class="panel-header" onclick="togglePanel('hair-particle-panel')">
    <h3>üåæ Hair Particle System</h3>
    <span class="toggle-btn">‚àí</span>
  </div>
  <div class="panel-content">
    <h4 style="font-size: 12px; margin-bottom: 8px;">Particle Type</h4>
    <button id="hair-grass-btn" onclick="window.setHairType('grass')" class="active">Grass</button>
    <button id="hair-fur-btn" onclick="window.setHairType('fur')">Fur</button>
    <button id="hair-spikes-btn" onclick="window.setHairType('spikes')">Spikes</button>
    <button id="hair-wheat-btn" onclick="window.setHairType('wheat')">Wheat</button>
    <button id="hair-crystal-btn" onclick="window.setHairType('crystal')">Crystals</button>
    
    <!-- NEW: Texture Section -->
    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">üé® Hair Texture</h4>
    <button onclick="document.getElementById('hair-texture-input').click()">Load Hair Texture</button>
    <button id="remove-hair-texture-btn" onclick="window.removeHairTexture()">Remove Texture</button>
    <div id="hair-texture-preview" style="width: 100%; height: 60px; background: #333; border: 2px solid #666; border-radius: 4px; margin: 8px 0; display: none; background-size: cover; background-position: center;"></div>
    
    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">Paint Mode</h4>
    <button id="toggle-hair-paint-btn" onclick="window.toggleHairPaintMode()">Enable Hair Paint</button>
    <p class="info-text">Click on terrain to add hair particles</p>
    
    <div class="slider-group">
      <label>Particle Density: <span class="value-display" id="hair-density-value">50</span></label>
      <input type="range" id="hair-density-slider" min="10" max="200" step="5" value="50">
    </div>
    
    <div class="slider-group">
      <label>Hair Length: <span class="value-display" id="hair-length-value">1.0</span></label>
      <input type="range" id="hair-length-slider" min="0.1" max="5" step="0.1" value="1.0">
    </div>
    
    <div class="slider-group">
      <label>Hair Thickness: <span class="value-display" id="hair-thickness-value">0.05</span></label>
      <input type="range" id="hair-thickness-slider" min="0.01" max="0.2" step="0.01" value="0.05">
    </div>
    
    <div class="slider-group">
      <label>Paint Radius: <span class="value-display" id="hair-radius-value">3.0</span></label>
      <input type="range" id="hair-radius-slider" min="0.5" max="10" step="0.5" value="3.0">
    </div>
    
    <div class="slider-group">
      <label>Wind Strength: <span class="value-display" id="hair-wind-value">0.2</span></label>
      <input type="range" id="hair-wind-slider" min="0" max="1" step="0.05" value="0.2">
    </div>
    
    <!-- NEW: Rotation Controls -->
    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">üîÑ Hair Transform</h4>
    <div class="slider-group">
      <label>Rotation X: <span class="value-display" id="hair-rot-x-value">0¬∞</span></label>
      <input type="range" id="hair-rot-x-slider" min="-180" max="180" step="5" value="0">
    </div>
    
    <div class="slider-group">
      <label>Rotation Y: <span class="value-display" id="hair-rot-y-value">0¬∞</span></label>
      <input type="range" id="hair-rot-y-slider" min="-180" max="180" step="5" value="0">
    </div>
    
    <div class="slider-group">
      <label>Rotation Z: <span class="value-display" id="hair-rot-z-value">0¬∞</span></label>
      <input type="range" id="hair-rot-z-slider" min="-180" max="180" step="5" value="0">
    </div>
    
    <div class="slider-group">
      <label>Position Offset Y: <span class="value-display" id="hair-offset-y-value">0.0</span></label>
      <input type="range" id="hair-offset-y-slider" min="-5" max="5" step="0.1" value="0">
    </div>
    
    <button id="reset-hair-transform-btn" onclick="window.resetHairTransform()">Reset Transform</button>
    
    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">Hair Color</h4>
    <input type="color" id="hair-color-picker" value="#4a7c2e" style="width: 100%; height: 40px; border: none; border-radius: 4px; cursor: pointer;">
    
    <div class="slider-group">
      <label>Color Variation: <span class="value-display" id="hair-color-var-value">0.3</span></label>
      <input type="range" id="hair-color-var-slider" min="0" max="1" step="0.1" value="0.3">
    </div>
    
    <h4 style="font-size: 12px; margin: 12px 0 8px 0;">Actions</h4>
    <button id="clear-hair-btn" onclick="window.clearHairParticles()">Clear All Hair</button>
    <button id="toggle-hair-vis-btn" onclick="window.toggleHairVisibility()">Hide Hair</button>
    
    <div style="margin-top: 12px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px;">
      <p style="font-size: 10px; color: #888; margin: 0;">
        Particle Count: <span id="hair-count-display" style="color: #4CAF50; font-weight: bold;">0</span>
      </p>
    </div>
  </div>
</div>

<!-- Add these hidden file inputs -->
<input type="file" id="paint-texture-1-input" accept="image/*" style="display: none;">
<input type="file" id="paint-texture-2-input" accept="image/*" style="display: none;">
<input type="file" id="paint-texture-3-input" accept="image/*" style="display: none;">


<!-- Add this input for texture selection -->
<input type="file" id="primitive-texture-input" accept="image/*">
 
  <h3 style="margin: 0 0 10px 0; font-size: 13px; color: #4CAF50;">
    Selected: <span id="selected-bone-name">None</span>
  </h3>




<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/examples/jsm/exporters/GLTFExporter": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/exporters/GLTFExporter.js",
    "three/examples/jsm/loaders/GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"
  }
}
</script>

<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/TransformControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fflate@0.6.9/umd/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/curves/NURBSCurve.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/curves/NURBSUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FBXLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/STLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

<script type="module">
import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter';

// Make GLTFExporter available globally
window.GLTFExporter = GLTFExporter;

// ============= UNDO/REDO SYSTEM =============
class UndoRedoManager {
  constructor(maxHistory = 50) {
    this.history = [];
    this.currentIndex = -1;
    this.maxHistory = maxHistory;
  }

  captureState() {
    const state = {
      models: window.models.map(model => ({
        id: model.userData.id,
        name: model.userData.name,
        position: model.position.clone(),
        rotation: model.rotation.clone(),
        scale: model.scale.clone(),
        visible: model.visible
      })),
      selectedModelId: window.selectedModel ? window.selectedModel.userData.id : null
    };
    return state;
  }

  pushState() {
    this.history = this.history.slice(0, this.currentIndex + 1);
    const state = this.captureState();
    this.history.push(state);
    
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    } else {
      this.currentIndex++;
    }
    
    this.updateButtons();
  }

  restoreState(state) {
    state.models.forEach(modelState => {
      const model = window.models.find(m => m.userData.id === modelState.id);
      if (model) {
        model.position.copy(modelState.position);
        model.rotation.copy(modelState.rotation);
        model.scale.copy(modelState.scale);
        model.visible = modelState.visible;
      }
    });

    if (state.selectedModelId) {
      const modelToSelect = window.models.find(m => m.userData.id === state.selectedModelId);
      if (modelToSelect) {
        window.selectModel(modelToSelect);
      }
    } else {
      window.selectModel(null);
    }
  }

  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      this.restoreState(this.history[this.currentIndex]);
      this.updateButtons();
      return true;
    }
    return false;
  }

  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      this.restoreState(this.history[this.currentIndex]);
      this.updateButtons();
      return true;
    }
    return false;
  }

  updateButtons() {
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    if (undoBtn) undoBtn.disabled = this.currentIndex <= 0;
    if (redoBtn) redoBtn.disabled = this.currentIndex >= this.history.length - 1;
  }

  clear() {
    this.history = [];
    this.currentIndex = -1;
    this.updateButtons();
  }
}

const undoManager = new UndoRedoManager();

// ============= GLB SAVE/LOAD SYSTEM =============

function saveSceneToGLB() {
  try {
    const exporter = new window.GLTFExporter();
    
    const exportGroup = new THREE.Group();
    exportGroup.name = 'ExportRoot';
    
    // ‚úÖ FIXED - Store scene metadata in a dedicated object
    const metadataObject = new THREE.Object3D();
    metadataObject.name = '_SCENE_METADATA_';
    metadataObject.userData = {
      isMetadata: true,
      cameraPosition: [camera.position.x, camera.position.y, camera.position.z],
      cameraRotation: [camera.rotation.x, camera.rotation.y, camera.rotation.z],
      cameraTarget: [orbitControls.target.x, orbitControls.target.y, orbitControls.target.z],
      ambientLightIntensity: ambientLight.intensity,
      ambientLightColor: ambientLight.color.getHex(),
      directionalLightIntensity: directionalLight.intensity,
      directionalLightPosition: [directionalLight.position.x, directionalLight.position.y, directionalLight.position.z],
      sceneBackground: scene.background ? scene.background.getHex() : null,
      gridVisible: gridHelper.visible
    };
    exportGroup.add(metadataObject);
    
    console.log('=== SAVE DEBUG ===');
    console.log('Models to export:', window.models.length);
    console.log('Texture planes to export:', window.texturePlanes.length);
    
    // ‚úÖ FIXED - Add all models with sanitization
    window.models.forEach((model, index) => {
      try {
        console.log(`Processing model ${index}:`, model.userData.name);
        
        const clonedModel = model.clone(true);
        
        // ‚úÖ CRITICAL FIX - Remove problematic properties and sanitize
        clonedModel.traverse((child) => {
          // Remove references that can't be serialized
          delete child.parent; // Will be recreated
          delete child.__removed; // Remove any cleanup flags
          
          // Clean up animations that might cause issues
          if (child.animations) {
            delete child.animations;
          }
          
          // Handle materials
          if (child.isMesh && child.material) {
            // Clone material properly
            if (Array.isArray(child.material)) {
              child.material = child.material.map(mat => {
                const clonedMat = mat.clone();
                sanitizeMaterial(clonedMat);
                return clonedMat;
              });
            } else {
              child.material = child.material.clone();
              sanitizeMaterial(child.material);
            }
          }
          
          // Store visibility
          if (child !== clonedModel) {
            child.userData.visible = child.visible;
          }
        });
        
        // Store model metadata
        clonedModel.userData = {
          id: model.userData.id,
          name: model.userData.name,
          modelType: 'imported',
          position: [model.position.x, model.position.y, model.position.z],
          rotation: [model.rotation.x, model.rotation.y, model.rotation.z],
          scale: [model.scale.x, model.scale.y, model.scale.z],
          visible: model.visible
        };
        
        exportGroup.add(clonedModel);
        console.log(`‚úì Model ${index} added to export`);
        
      } catch (modelError) {
        console.error(`Error processing model ${index}:`, modelError);
        // Continue with other models
      }
    });
    
    // Add texture planes
    window.texturePlanes.forEach((plane, index) => {
      try {
        const clonedPlane = plane.clone(true);
        
        // Sanitize material
        if (clonedPlane.material) {
          clonedPlane.material = clonedPlane.material.clone();
          sanitizeMaterial(clonedPlane.material);
        }
        
        clonedPlane.userData = {
          id: plane.userData.id,
          name: plane.userData.name,
          isTexturePlane: true,
          position: [plane.position.x, plane.position.y, plane.position.z],
          rotation: [plane.rotation.x, plane.rotation.y, plane.rotation.z],
          scale: [plane.scale.x, plane.scale.y, plane.scale.z],
          visible: plane.visible
        };
        exportGroup.add(clonedPlane);
        console.log(`‚úì Texture plane ${index} added to export`);
      } catch (planeError) {
        console.error(`Error processing texture plane ${index}:`, planeError);
      }
    });
    
    // Add ground plane with texture info
    if (window.groundPlane) {
      try {
        const clonedGround = window.groundPlane.clone(true);
        
        // Sanitize material
        if (clonedGround.material) {
          clonedGround.material = clonedGround.material.clone();
          sanitizeMaterial(clonedGround.material);
        }
        
        clonedGround.userData = { 
          isGroundPlane: true,
          position: [window.groundPlane.position.x, window.groundPlane.position.y, window.groundPlane.position.z],
          rotation: [window.groundPlane.rotation.x, window.groundPlane.rotation.y, window.groundPlane.rotation.z],
          scale: [window.groundPlane.scale.x, window.groundPlane.scale.y, window.groundPlane.scale.z],
          textureRepeat: window.groundPlane.material.map ? 
            [window.groundPlane.material.map.repeat.x, window.groundPlane.material.map.repeat.y] : null,
          visible: window.groundPlane.visible
        };
        exportGroup.add(clonedGround);
        console.log('‚úì Ground plane added to export');
      } catch (groundError) {
        console.error('Error processing ground plane:', groundError);
      }
    }
    
    // Add sky sphere
    if (window.skySphere) {
      try {
        const clonedSky = window.skySphere.clone(true);
        
        // Sanitize material
        if (clonedSky.material) {
          clonedSky.material = clonedSky.material.clone();
          sanitizeMaterial(clonedSky.material);
        }
        
        clonedSky.userData = { 
          isSkySphere: true,
          position: [window.skySphere.position.x, window.skySphere.position.y, window.skySphere.position.z],
          rotation: [window.skySphere.rotation.x, window.skySphere.rotation.y, window.skySphere.rotation.z],
          scale: [window.skySphere.scale.x, window.skySphere.scale.y, window.skySphere.scale.z],
          visible: window.skySphere.visible
        };
        exportGroup.add(clonedSky);
        console.log('‚úì Sky sphere added to export');
      } catch (skyError) {
        console.error('Error processing sky sphere:', skyError);
      }
    }
    
    console.log('Total objects in export group:', exportGroup.children.length);
    
    // ‚úÖ FIXED - Corrected export options
    const options = {
      binary: true,
      maxTextureSize: 4096,
      embedImages: true,
      truncateDrawRange: false,
      forceIndices: true,
      forcePowerOfTwoTextures: false,
      includeCustomExtensions: false,  // Changed to false - can cause issues
      onlyVisible: false  // Export hidden objects too
    };
    
    console.log('Starting GLTFExporter.parse...');
    
    exporter.parse(
      exportGroup,
      (result) => {
        console.log('‚úì Export successful, result size:', result.byteLength, 'bytes');
        
        const blob = new Blob([result], { type: 'model/gltf-binary' });
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const filename = `cookup_scene_${timestamp}.glb`;
        
        // Check blob size
        if (blob.size === 0) {
          alert('‚ùå Error: Generated GLB file is empty!');
          return;
        }
        
        console.log('Blob created, size:', blob.size, 'bytes');
        
        // ‚úÖ FIXED - Improved Web Share API implementation
        if (navigator.share) {
          const file = new File([blob], filename, { type: 'model/gltf-binary' });
          
          // Check if we can share files
          if (navigator.canShare && navigator.canShare({ files: [file] })) {
            navigator.share({
              title: 'COOKuP Scene',
              text: 'Check out my 3D scene!',
              files: [file]
            })
            .then(() => {
              console.log('‚úì Scene shared successfully');
              showSaveSuccess();
            })
            .catch((error) => {
              if (error.name !== 'AbortError') {
                console.log('Share failed, downloading instead:', error);
                downloadScene(blob, filename);
              }
            });
          } else {
            // File sharing not supported, download instead
            console.log('File sharing not supported, downloading...');
            downloadScene(blob, filename);
          }
        } else {
          // Web Share API not available
          console.log('Web Share API not available, downloading...');
          downloadScene(blob, filename);
        }
      },
      (error) => {
        console.error('GLB export error:', error);
        console.error('Error name:', error.name);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
        
        // More detailed error message
        let errorMsg = 'Error exporting scene to GLB!\n\n';
        errorMsg += `Error: ${error.message || 'Unknown error'}\n`;
        errorMsg += `Type: ${error.name || 'TypeError'}\n\n`;
        errorMsg += 'This might be caused by:\n';
        errorMsg += '‚Ä¢ Corrupted model geometry\n';
        errorMsg += '‚Ä¢ Invalid textures\n';
        errorMsg += '‚Ä¢ Unsupported material properties\n';
        errorMsg += '‚Ä¢ Large file size\n\n';
        errorMsg += 'Check browser console for details.';
        
        alert(`‚ùå ${errorMsg}`);
      },
      options
    );
  } catch (error) {
    console.error('Error saving scene as GLB:', error);
    console.error('Stack:', error.stack);
    alert(`‚ùå Error saving scene!\n\n${error.message}\n\nCheck console for details.`);
  }
}

// ‚úÖ NEW HELPER FUNCTION - Sanitize materials for export
function sanitizeMaterial(material) {
  if (!material) return;
  
  try {
    // Remove custom properties that can't be serialized
    delete material.onBeforeCompile;
    delete material.customProgramCacheKey;
    
    // Ensure side is a valid number
    if (material.side !== undefined) {
      material.side = Number(material.side);
    }
    
    // Handle texture properties
    const textureProps = ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 
                          'aoMap', 'emissiveMap', 'bumpMap', 'displacementMap',
                          'alphaMap', 'lightMap', 'envMap'];
    
    textureProps.forEach(prop => {
      if (material[prop]) {
        const texture = material[prop];
        
        // Remove circular references
        delete texture.source;
        
        // Ensure wrap modes are valid numbers
        if (texture.wrapS !== undefined) texture.wrapS = Number(texture.wrapS);
        if (texture.wrapT !== undefined) texture.wrapT = Number(texture.wrapT);
        
        // Ensure filter modes are valid
        if (texture.magFilter !== undefined) texture.magFilter = Number(texture.magFilter);
        if (texture.minFilter !== undefined) texture.minFilter = Number(texture.minFilter);
        
        // Clean up texture
        delete texture.onUpdate;
        delete texture.userData;
      }
    });
    
    // Ensure numeric properties are valid
    if (material.opacity !== undefined) material.opacity = Number(material.opacity) || 1;
    if (material.metalness !== undefined) material.metalness = Number(material.metalness) || 0;
    if (material.roughness !== undefined) material.roughness = Number(material.roughness) || 1;
    
    // Clean up color objects
    if (material.color && material.color.isColor) {
      const hex = material.color.getHex();
      material.color.setHex(hex); // Normalize
    }
    
  } catch (err) {
    console.warn('Error sanitizing material:', err);
  }
}


// Keep the loadSceneFromGLB, downloadScene, and showSaveSuccess functions the same as before
function loadSceneFromGLB(file) {
  const reader = new FileReader();
  
  reader.onload = (e) => {
    const loader = new THREE.GLTFLoader();
    
    loader.parse(e.target.result, '', (gltf) => {
      try {
        // Clear scene first
        clearScene();
        
        // Reset counters
        modelCounter = 0;
        texturePlaneCounter = 0;
        
        console.log('=== GLB LOAD DEBUG ===');
        console.log('Full GLTF object:', gltf);
        console.log('Scene children count:', gltf.scene.children.length);
        
        // Get all children
        const children = [...gltf.scene.children];
        
        console.log(`Processing ${children.length} children...`);
        
        // Find and restore metadata first
        const metadataChild = children.find(c => c.name === '_SCENE_METADATA_' || c.userData.isMetadata);
        let metadata = null;
        
        if (metadataChild) {
          metadata = metadataChild.userData;
          console.log('Found metadata:', metadata);
          
          // Restore camera
          if (metadata.cameraPosition) {
            camera.position.fromArray(metadata.cameraPosition);
            camera.rotation.fromArray(metadata.cameraRotation);
            orbitControls.target.fromArray(metadata.cameraTarget);
            orbitControls.update();
            console.log('‚úì Camera restored');
          }
          
          // Restore grid visibility
          if (metadata.gridVisible !== undefined) {
            gridHelper.visible = metadata.gridVisible;
          }
          
          // Restore lights
          if (metadata.ambientLightIntensity !== undefined) {
            ambientLight.intensity = metadata.ambientLightIntensity;
          }
          if (metadata.ambientLightColor !== undefined) {
            ambientLight.color.setHex(metadata.ambientLightColor);
          }
          if (metadata.directionalLightIntensity !== undefined) {
            directionalLight.intensity = metadata.directionalLightIntensity;
          }
          if (metadata.directionalLightPosition) {
            directionalLight.position.fromArray(metadata.directionalLightPosition);
          }
          
          // Restore scene background
          if (metadata.sceneBackground !== null && metadata.sceneBackground !== undefined) {
            scene.background = new THREE.Color(metadata.sceneBackground);
          }
          
          // Remove metadata from children array
          const metaIndex = children.indexOf(metadataChild);
          if (metaIndex > -1) {
            children.splice(metaIndex, 1);
          }
        }
        
        let modelsLoaded = 0;
        let planesLoaded = 0;
        let groundLoaded = false;
        let skyLoaded = false;
        
        // Process remaining children
        children.forEach((child, index) => {
          console.log(`\n--- Processing child ${index}: ${child.name || 'unnamed'} ---`);
          
          const userData = child.userData || {};
          console.log('Child userData:', userData);
          
          // GROUND PLANE
          if (userData.isGroundPlane) {
            console.log('‚Üí Identified as GROUND PLANE');
            
            // Clean up existing ground plane
            if (window.groundPlane) {
              scene.remove(window.groundPlane);
              if (window.groundPlane.geometry) window.groundPlane.geometry.dispose();
              if (window.groundPlane.material) {
                if (window.groundPlane.material.map) window.groundPlane.material.map.dispose();
                window.groundPlane.material.dispose();
              }
            }
            
            // Find mesh in child hierarchy
            let mesh = child.isMesh ? child : null;
            if (!mesh) {
              child.traverse((c) => {
                if (c.isMesh && !mesh) {
                  mesh = c;
                  console.log('Found mesh in children:', c);
                }
              });
            }
            
            if (mesh) {
              // Create new ground plane from loaded mesh
              window.groundPlane = new THREE.Mesh(
                mesh.geometry.clone(),
                mesh.material.clone()
              );
              window.groundPlane.userData = { isGroundPlane: true };
              
              // Restore transforms
              if (userData.position) {
                window.groundPlane.position.fromArray(userData.position);
                console.log('Ground position:', userData.position);
              }
              if (userData.rotation) {
                window.groundPlane.rotation.fromArray(userData.rotation);
              }
              if (userData.scale) {
                window.groundPlane.scale.fromArray(userData.scale);
              }
              if (userData.textureRepeat && window.groundPlane.material.map) {
                window.groundPlane.material.map.repeat.fromArray(userData.textureRepeat);
                window.groundPlane.material.map.needsUpdate = true;
              }
              
              // Restore visibility
              window.groundPlane.visible = userData.visible !== undefined ? userData.visible : true;
              window.groundPlane.material.needsUpdate = true;
              
              scene.add(window.groundPlane);
              groundLoaded = true;
              console.log('‚úì Ground plane loaded');
            } else {
              console.log('‚úó No mesh found for ground plane');
            }
          }
          // SKY SPHERE
          else if (userData.isSkySphere) {
            console.log('‚Üí Identified as SKY SPHERE');
            
            // Find mesh in child hierarchy
            let mesh = child.isMesh ? child : null;
            if (!mesh) {
              child.traverse((c) => {
                if (c.isMesh && !mesh) {
                  mesh = c;
                }
              });
            }
            
            if (mesh) {
              // Clean up existing sky sphere
              if (window.skySphere) {
                scene.remove(window.skySphere);
                if (window.skySphere.geometry) window.skySphere.geometry.dispose();
                if (window.skySphere.material) {
                  if (window.skySphere.material.map) window.skySphere.material.map.dispose();
                  window.skySphere.material.dispose();
                }
              }
              
              window.skySphere = new THREE.Mesh(
                mesh.geometry.clone(),
                mesh.material.clone()
              );
              window.skySphere.userData = { isSkySphere: true };
              
              // Restore transforms
              if (userData.position) window.skySphere.position.fromArray(userData.position);
              if (userData.rotation) window.skySphere.rotation.fromArray(userData.rotation);
              if (userData.scale) window.skySphere.scale.fromArray(userData.scale);
              
              // Restore visibility
              window.skySphere.visible = userData.visible !== undefined ? userData.visible : true;
              
              // Store texture reference
              if (window.skySphere.material.map) {
                window.skyTexture = window.skySphere.material.map;
              }
              
              scene.add(window.skySphere);
              skyLoaded = true;
              console.log('‚úì Sky sphere loaded');
            } else {
              console.log('‚úó No mesh found for sky sphere');
            }
          }
          // TEXTURE PLANE
          else if (userData.isTexturePlane) {
            console.log('‚Üí Identified as TEXTURE PLANE');
            
            // Find mesh in child hierarchy
            let mesh = child.isMesh ? child : null;
            if (!mesh) {
              child.traverse((c) => {
                if (c.isMesh && !mesh) {
                  mesh = c;
                }
              });
            }
            
            if (mesh) {
              const plane = new THREE.Mesh(
                mesh.geometry.clone(),
                mesh.material.clone()
              );
              
              plane.userData = { ...userData };
              
              // Restore transforms
              if (userData.position) plane.position.fromArray(userData.position);
              if (userData.rotation) plane.rotation.fromArray(userData.rotation);
              if (userData.scale) plane.scale.fromArray(userData.scale);
              
              // Restore visibility
              plane.visible = userData.visible !== undefined ? userData.visible : true;
              
              // Ensure ID is set
              if (!plane.userData.id) {
                texturePlaneCounter++;
                plane.userData.id = texturePlaneCounter;
              } else {
                texturePlaneCounter = Math.max(texturePlaneCounter, plane.userData.id);
              }
              
              if (!plane.userData.name) {
                plane.userData.name = `Texture ${texturePlaneCounter}`;
              }
              
              window.scene.add(plane);
              window.texturePlanes.push(plane);
              planesLoaded++;
              console.log('‚úì Texture plane loaded:', plane.userData.name);
            } else {
              console.log('‚úó No mesh found for texture plane');
            }
          }
          // MODEL (anything else)
          else {
            console.log('‚Üí Identified as MODEL');
            
            // Remove from gltf.scene before adding to our scene
            gltf.scene.remove(child);
            
            // Use the child directly
            const model = child;
            
            // Restore transforms from userData if available
            if (userData.position) {
              model.position.fromArray(userData.position);
              console.log('Model position:', userData.position);
            }
            if (userData.rotation) {
              model.rotation.fromArray(userData.rotation);
              console.log('Model rotation:', userData.rotation);
            }
            if (userData.scale) {
              model.scale.fromArray(userData.scale);
              console.log('Model scale:', userData.scale);
            }
            
            // Restore visibility for model and all children
            model.visible = userData.visible !== undefined ? userData.visible : true;
            
            // Restore child visibility
            model.traverse((child) => {
              if (child.userData.visible !== undefined) {
                child.visible = child.userData.visible;
              }
            });
            
            // Restore material properties
            if (userData.materialProps) {
              model.traverse((meshChild) => {
                if (meshChild.isMesh && meshChild.material) {
                  const props = userData.materialProps;
                  if (props.color !== undefined) meshChild.material.color.setHex(props.color);
                  if (props.roughness !== undefined) meshChild.material.roughness = props.roughness;
                  if (props.metalness !== undefined) meshChild.material.metalness = props.metalness;
                  if (props.transparent !== undefined) meshChild.material.transparent = props.transparent;
                  if (props.opacity !== undefined) meshChild.material.opacity = props.opacity;
                  meshChild.material.needsUpdate = true;
                }
              });
            }
            
            // Ensure model has an ID
            if (!model.userData.id) {
              modelCounter++;
              model.userData.id = modelCounter;
            } else {
              modelCounter = Math.max(modelCounter, model.userData.id);
            }
            
            if (!model.userData.name) {
              model.userData.name = `Model ${window.models.length + 1}`;
            }
            
            // Detect bones
            if (typeof detectBones === 'function') {
              detectBones(model);
            }
            
            window.scene.add(model);
            window.models.push(model);
            modelsLoaded++;
            console.log('‚úì Model loaded:', model.userData.name, 'ID:', model.userData.id);
          }
        });
        
        console.log('\n=== LOAD SUMMARY ===');
        console.log('Models:', modelsLoaded);
        console.log('Texture planes:', planesLoaded);
        console.log('Ground:', groundLoaded);
        console.log('Sky:', skyLoaded);
        console.log('Total models array:', window.models.length);
        console.log('Total texturePlanes array:', window.texturePlanes.length);
        
        // Update UI
        if (typeof window.updateObjectList === 'function') {
          window.updateObjectList();
        }
        if (typeof window.updateTexturePlaneList === 'function') {
          window.updateTexturePlaneList();
        }
        if (typeof undoManager !== 'undefined' && undoManager.pushState) {
          undoManager.pushState();
        }
        
        let message = '‚úì GLB Scene loaded successfully!\n\n';
        message += `üì¶ Models loaded: ${modelsLoaded}\n`;
        message += `üñºÔ∏è Texture planes: ${planesLoaded}\n`;
        if (groundLoaded) message += `üåç Ground plane: restored\n`;
        if (skyLoaded) message += `üå§Ô∏è Sky sphere: restored\n`;
        
        alert(message);
        
        const loadBtn = document.getElementById('load-scene-btn');
        if (loadBtn) {
          const originalText = loadBtn.textContent;
          const originalBg = loadBtn.style.backgroundColor;
          loadBtn.textContent = '‚úì Loaded!';
          loadBtn.style.backgroundColor = '#4CAF50';
          setTimeout(() => {
            loadBtn.textContent = originalText;
            loadBtn.style.backgroundColor = originalBg;
          }, 2000);
        }
        
      } catch (error) {
        console.error('Error processing GLB scene:', error);
        console.error('Stack trace:', error.stack);
        alert(`‚ùå Error loading GLB scene!\n\n${error.message}`);
      }
    }, (error) => {
      console.error('Error parsing GLB:', error);
      alert(`‚ùå Error parsing GLB file!\n\n${error.message}`);
    });
  };
  
  reader.onerror = (error) => {
    console.error('FileReader error:', error);
    alert(`‚ùå Error reading file!\n${error.target?.error?.message || 'Unknown error'}`);
  };
  
  reader.readAsArrayBuffer(file);
}



function downloadScene(dataBlob, filename) {
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  setTimeout(() => URL.revokeObjectURL(url), 100);

  console.log(`‚úì Scene saved as: ${filename}`);
  showSaveSuccess();
}

function showSaveSuccess() {
  const saveBtn = document.getElementById('save-scene-btn');
  if (saveBtn) {
    const originalText = saveBtn.textContent;
    const originalBg = saveBtn.style.backgroundColor;
    saveBtn.textContent = '‚úì Saved!';
    saveBtn.style.backgroundColor = '#4CAF50';
    setTimeout(() => {
      saveBtn.textContent = originalText;
      saveBtn.style.backgroundColor = originalBg;
    }, 2000);
  }
}



function clearScene() {
  // Clear models
  window.models.forEach(model => {
    window.scene.remove(model);
    if (model.geometry) model.geometry.dispose();
    if (model.material) {
      if (Array.isArray(model.material)) {
        model.material.forEach(mat => mat.dispose());
      } else {
        model.material.dispose();
      }
    }
  });
  window.models.length = 0;
  
  // Clear texture planes
  window.texturePlanes.forEach(plane => {
    window.scene.remove(plane);
    if (plane.geometry) plane.geometry.dispose();
    if (plane.material) {
      if (plane.material.map) plane.material.map.dispose();
      plane.material.dispose();
    }
  });
  window.texturePlanes.length = 0;
  
  // ‚úÖ ADDED - Clear ground plane
  if (window.groundPlane) {
    window.scene.remove(window.groundPlane);
    if (window.groundPlane.geometry) window.groundPlane.geometry.dispose();
    if (window.groundPlane.material) {
      if (window.groundPlane.material.map) window.groundPlane.material.map.dispose();
      window.groundPlane.material.dispose();
    }
    window.groundPlane = null;
  }
  
  // ‚úÖ ADDED - Clear sky sphere
  if (window.skySphere) {
    window.scene.remove(window.skySphere);
    if (window.skySphere.geometry) window.skySphere.geometry.dispose();
    if (window.skySphere.material) {
      if (window.skySphere.material.map) window.skySphere.material.map.dispose();
      window.skySphere.material.dispose();
    }
    window.skySphere = null;
  }
  
  // ‚úÖ ADDED - Clear sky texture
  if (window.skyTexture) {
    window.skyTexture.dispose();
    window.skyTexture = null;
  }
  
  // ‚úÖ ADDED - Deselect everything
  if (window.selectedModel) {
    transformControls.detach();
    window.selectedModel = null;
  }
  window.selectedBone = null;
  
  // Update UI
  window.updateObjectList();
  window.updateTexturePlaneList();
  window.updateBoneList();
}


// ============= SCENE INITIALIZATION =============
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x2a2a2a);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
  preserveDrawingBuffer: true,
  alpha: true,
  premultipliedAlpha: false,
});

renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.NoToneMapping;  // Changed from LinearToneMapping
renderer.toneMappingExposure = 1.0; // ‚úÖ FIXED
renderer.outputColorSpace = THREE.SRGBColorSpace;

document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // ‚úÖ FIXED
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
directionalLight.position.set(5, 10, 7.5);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 2048; // ‚úÖ FIXED (was 2)
directionalLight.shadow.mapSize.height = 2048; // ‚úÖ FIXED (was 2)
directionalLight.shadow.camera.left = -10; // ‚úÖ FIXED (was 1)
directionalLight.shadow.camera.right = 10; // ‚úÖ FIXED (was 1)
directionalLight.shadow.camera.top = 10; // ‚úÖ FIXED (was 1)
directionalLight.shadow.camera.bottom = -10; // ‚úÖ FIXED (was 1)
scene.add(directionalLight);



const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
scene.add(gridHelper);

let groundPlane = null;
let skySphere = null;
let skyTexture = null;
let originalBackground = scene.background.clone();

function addTerrainToGroundPlane(planeGeometry, maxHeight = 0) {
  const positionAttribute = planeGeometry.attributes.position;
  
  for (let i = 0; i < positionAttribute.count; i++) {
    const x = positionAttribute.array[i * 3];
    const y = positionAttribute.array[i * 3 + 1];
    const z = Math.random() * maxHeight;
    positionAttribute.array[i * 3 + 2] = z;
  }
  
    positionAttribute.needsUpdate = true;
  planeGeometry.computeVertexNormals();
}

function createGroundPlane() {
  if (groundPlane) {
    scene.remove(groundPlane);
    if (groundPlane.geometry) groundPlane.geometry.dispose();
    if (groundPlane.material) groundPlane.material.dispose();
  }

  const geometry = new THREE.PlaneGeometry(600, 600 );
  
  const material = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    side: THREE.DoubleSide,
    roughness: 30.0,
    metalness: 0.0,
    emissive: 0x000000,
    emissiveIntensity: 0,
    toneMapped: false,
    depthWrite: true,
    depthTest: true,
  });

  groundPlane = new THREE.Mesh(geometry, material);
  groundPlane.rotation.x = -Math.PI / 2;
  groundPlane.position.y = -1;
  
  groundPlane.receiveShadow = true;
  groundPlane.userData.isGroundPlane = true;
  groundPlane.renderOrder = -1;
  scene.add(groundPlane);
  addTerrainToGroundPlane(geometry, 0);
  return groundPlane;
}

function createSkySphere() {
  if (skySphere) {
    scene.remove(skySphere);
    if (skySphere.geometry) skySphere.geometry.dispose();
    if (skySphere.material) {
      if (skySphere.material.map) skySphere.material.map.dispose();
      skySphere.material.dispose();
    }
  }
  
  const skyGeometry = new THREE.SphereGeometry(400, 400, 400);
  const skyMaterial = new THREE.MeshBasicMaterial({
    map: skyTexture,
    side: THREE.BackSide,
    toneMapped: false,
  });
  
  skySphere = new THREE.Mesh(skyGeometry, skyMaterial);
  skySphere.userData = { isSkySphere: true };
  scene.add(skySphere);
}

camera.position.set(10, 10, 10);
camera.lookAt(0, 0, 0);

const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
orbitControls.enableDamping = false;


const transformControls = new THREE.TransformControls(camera, renderer.domElement);
scene.add(transformControls);

transformControls.addEventListener('dragging-changed', (event) => {
  orbitControls.enabled = !event.value;
});

let isTransforming = false;
transformControls.addEventListener('mouseDown', () => {
  isTransforming = true;
});

transformControls.addEventListener('mouseUp', () => {
  if (isTransforming) {
    undoManager.pushState();
    isTransforming = false;
  }
});

const models = [];
let selectedModel = null;
let modelCounter = 0;

let bones = [];
let selectedBone = null;
let boneHelpers = [];
let showBones = false;
let showBoneHelpers = false;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

const texturePlanes = [];
let texturePlaneCounter = 0;

// ============= FILE INPUT HANDLERS =============

const fileInput = document.getElementById('file-input');
if (fileInput) {
  fileInput.addEventListener('change', (event) => {
    const files = Array.from(event.target.files);
    
    files.forEach((file, index) => {
      loadModel(file, index);
    });
    
    event.target.value = '';
  });
}

// ============= PRIMITIVES SYSTEM =============

let primitiveCounter = 0;

// Function to add primitive shapes
window.addPrimitive = function(type) {
  let geometry;
  let name;
  
  switch(type) {
    case 'plane':
      geometry = new THREE.PlaneGeometry(2, 2, 10, 10);
      name = 'Plane';
      break;
    case 'cube':
      geometry = new THREE.BoxGeometry(2, 2, 2);
      name = 'Cube';
      break;
    case 'sphere':
      geometry = new THREE.SphereGeometry(1, 32, 32);
      name = 'Sphere';
      break;
    case 'cylinder':
      geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
      name = 'Cylinder';
      break;
    case 'cone':
      geometry = new THREE.ConeGeometry(1, 2, 32);
      name = 'Cone';
      break;
    case 'torus':
      geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
      name = 'Torus';
      break;
    case 'ring':
      geometry = new THREE.RingGeometry(0.5, 1.5, 32);
      name = 'Ring';
      break;
    default:
      console.error('Unknown primitive type:', type);
      return;
  }
  
  // Create material with standard properties
  const material = new THREE.MeshStandardMaterial({
    color: 0x808080,
    roughness: 0.7,
    metalness: 0.0,
    side: THREE.DoubleSide,
    toneMapped: false,
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(0, 1, 0);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  
  // Add to scene
  primitiveCounter++;
  modelCounter++;
  mesh.userData = {
    id: modelCounter,
    name: `$${name}$$ {primitiveCounter}`,
    originalName: name,
    isPrimitive: true,
    primitiveType: type,
    bones: []
  };
  
  scene.add(mesh);
  models.push(mesh);
  selectModel(mesh);
  updateObjectList();
  undoManager.pushState();
  
  console.log(`Added ${name} primitive`);
};

// Function to apply texture to selected primitive
window.applyTextureToSelected = function() {
  if (!selectedModel) {
    alert('Please select an object first');
    return;
  }
  
  const input = document.getElementById('primitive-texture-input');
  if (input) {
    input.click();
  }
};

// Handle texture application
const primitiveTextureInput = document.getElementById('primitive-texture-input');
if (primitiveTextureInput) {
  primitiveTextureInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file || !selectedModel) {
      event.target.value = '';
      return;
    }
    
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      event.target.value = '';
      return;
    }
    
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(URL.createObjectURL(file), (texture) => {
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      texture.encoding = THREE.sRGBEncoding;
      
      // Apply texture to selected model
      selectedModel.traverse((child) => {
        if (child.isMesh && child.material) {
          if (child.material.map) {
            child.material.map.dispose();
          }
          child.material.map = texture;
          child.material.needsUpdate = true;
        }
      });
      
      console.log('Texture applied to', selectedModel.userData.name);
    }, undefined, (error) => {
      console.error('Error loading texture:', error);
      alert('Failed to load texture');
    });
    
    event.target.value = '';
  });
}

// Function to change primitive color
window.changePrimitiveColor = function() {
  if (!selectedModel) {
    alert('Please select an object first');
    return;
  }
  
  const input = document.createElement('input');
  input.type = 'color';
  input.value = '#808080';
  
  input.addEventListener('change', (e) => {
    const color = new THREE.Color(e.target.value);
    
    selectedModel.traverse((child) => {
      if (child.isMesh && child.material) {
        child.material.color = color;
        child.material.needsUpdate = true;
      }
    });
    
    undoManager.pushState();
  });
  
  input.click();
};

// Material property sliders
const metalnessSlider = document.getElementById('metalness-slider');
if (metalnessSlider) {
  metalnessSlider.addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    const valueDisplay = document.getElementById('metalness-value');
    if (valueDisplay) valueDisplay.textContent = value.toFixed(1);
    
    if (selectedModel) {
      selectedModel.traverse((child) => {
        if (child.isMesh && child.material) {
          child.material.metalness = value;
          child.material.needsUpdate = true;
        }
      });
    }
  });
}

const roughnessSlider = document.getElementById('roughness-slider');
if (roughnessSlider) {
  roughnessSlider.addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    const valueDisplay = document.getElementById('roughness-value');
    if (valueDisplay) valueDisplay.textContent = value.toFixed(1);
    
    if (selectedModel) {
      selectedModel.traverse((child) => {
        if (child.isMesh && child.material) {
          child.material.roughness = value;
          child.material.needsUpdate = true;
        }
      });
    }
  });
}

const opacitySlider = document.getElementById('opacity-slider');
if (opacitySlider) {
  opacitySlider.addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    const valueDisplay = document.getElementById('opacity-value');
    if (valueDisplay) valueDisplay.textContent = value.toFixed(1);
    
    if (selectedModel) {
      selectedModel.traverse((child) => {
        if (child.isMesh && child.material) {
          child.material.opacity = value;
          child.material.transparent = value < 1.0;
          child.material.needsUpdate = true;
        }
      });
    }
  });
}

// Update sliders when selecting an object
const originalSelectModel = window.selectModel;
window.selectModel = function(model) {
  originalSelectModel(model);
  
  // Update material sliders
  if (model) {
    let material = null;
    model.traverse((child) => {
      if (child.isMesh && child.material && !material) {
        material = child.material;
      }
    });
    
    if (material) {
      const metalnessSlider = document.getElementById('metalness-slider');
      const roughnessSlider = document.getElementById('roughness-slider');
      const opacitySlider = document.getElementById('opacity-slider');
      
      if (metalnessSlider && material.metalness !== undefined) {
        metalnessSlider.value = material.metalness;
        document.getElementById('metalness-value').textContent = material.metalness.toFixed(1);
      }
      
      if (roughnessSlider && material.roughness !== undefined) {
        roughnessSlider.value = material.roughness;
        document.getElementById('roughness-value').textContent = material.roughness.toFixed(1);
      }
      
      if (opacitySlider && material.opacity !== undefined) {
        opacitySlider.value = material.opacity;
        document.getElementById('opacity-value').textContent = material.opacity.toFixed(1);
      }
    }
  }
};

// ============= PANEL TOGGLE =============

window.togglePanel = function(panelId) {
  const panel = document.getElementById(panelId);
  if (!panel) return;
  
  const content = panel.querySelector('.panel-content');
  const toggleBtn = panel.querySelector('.toggle-btn');
  
  if (!content || !toggleBtn) return;
  
  if (content.classList.contains('collapsed')) {
    content.classList.remove('collapsed');
    toggleBtn.textContent = '‚àí';
    panel.classList.remove('collapsed');
  } else {
    content.classList.add('collapsed');
    toggleBtn.textContent = '+';
    panel.classList.add('collapsed');
  }
}
// ============= DRAGGABLE PANELS SYSTEM =============

class DraggablePanel {
  constructor(panelId) {
    this.panel = document.getElementById(panelId);
    if (!this.panel) return;
    
    this.header = this.panel.querySelector('.panel-header');
    if (!this.header) return;
    
    this.isDragging = false;
    this.currentX = 0;
    this.currentY = 0;
    this.initialX = 0;
    this.initialY = 0;
    this.xOffset = 0;
    this.yOffset = 0;
    
    // Get initial position from CSS
    const style = window.getComputedStyle(this.panel);
    this.xOffset = parseInt(style.left) || 0;
    this.yOffset = parseInt(style.top) || 0;
    
    this.initDrag();
  }
  
  initDrag() {
    // Mouse events
    this.header.addEventListener('mousedown', (e) => this.dragStart(e));
    document.addEventListener('mousemove', (e) => this.drag(e));
    document.addEventListener('mouseup', () => this.dragEnd());
    
    // Touch events
    this.header.addEventListener('touchstart', (e) => this.dragStart(e), { passive: false });
    document.addEventListener('touchmove', (e) => this.drag(e), { passive: false });
    document.addEventListener('touchend', () => this.dragEnd());
  }
  
  dragStart(e) {
    // Don't drag if clicking toggle button
    if (e.target.classList.contains('toggle-btn')) {
      return;
    }
    
    if (e.type === 'touchstart') {
      this.initialX = e.touches[0].clientX - this.xOffset;
      this.initialY = e.touches[0].clientY - this.yOffset;
    } else {
      this.initialX = e.clientX - this.xOffset;
      this.initialY = e.clientY - this.yOffset;
    }
    
    this.isDragging = true;
    this.panel.classList.add('dragging');
  }
  
  drag(e) {
    if (!this.isDragging) return;
    
    e.preventDefault();
    
    if (e.type === 'touchmove') {
      this.currentX = e.touches[0].clientX - this.initialX;
      this.currentY = e.touches[0].clientY - this.initialY;
    } else {
      this.currentX = e.clientX - this.initialX;
      this.currentY = e.clientY - this.initialY;
    }
    
    this.xOffset = this.currentX;
    this.yOffset = this.currentY;
    
    // Constrain to viewport
    const maxX = window.innerWidth - this.panel.offsetWidth;
    const maxY = window.innerHeight - this.panel.offsetHeight;
    
    this.xOffset = Math.max(0, Math.min(this.xOffset, maxX));
    this.yOffset = Math.max(0, Math.min(this.yOffset, maxY));
    
    this.setTranslate(this.xOffset, this.yOffset);
  }
  
  dragEnd() {
    this.isDragging = false;
    this.panel.classList.remove('dragging');
  }
  
  setTranslate(xPos, yPos) {
    this.panel.style.left = `${xPos}px`;
    this.panel.style.top = `${yPos}px`;
  }
}

// Initialize draggable panels
const draggablePanels = [
  'upload-container',
  'controls',
  'object-list',
  'texture-controls',
  'bone-controls',
  'save-load-controls',
  'primitives-panel',
  'terrain-panel',
  'hair-particle-panel' // New panel we'll create
];

// Wait for DOM to be ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeDraggablePanels);
} else {
  initializeDraggablePanels();
}

function initializeDraggablePanels() {
  draggablePanels.forEach(panelId => {
    new DraggablePanel(panelId);
  });
  console.log('‚úì All panels are now draggable');
}
// ============= ENHANCED HAIR PARTICLE SYSTEM WITH TEXTURES & TRANSFORMS =============

let hairParticleSystem = {
  enabled: false,
  type: 'grass',
  density: 50,
  length: 1.0,
  thickness: 0.05,
  paintRadius: 3.0,
  windStrength: 0.2,
  color: new THREE.Color(0x4a7c2e),
  colorVariation: 0.3,
  instances: [],
  meshes: [],
  visible: true,
  texture: null, // NEW
  rotationX: 0,  // NEW
  rotationY: 0,  // NEW
  rotationZ: 0,  // NEW
  offsetY: 0     // NEW
};

let isHairPainting = false;
let hairInstancedMeshes = new Map();

// Set hair type
window.setHairType = function(type) {
  hairParticleSystem.type = type;
  
  document.getElementById('hair-grass-btn').classList.remove('active');
  document.getElementById('hair-fur-btn').classList.remove('active');
  document.getElementById('hair-spikes-btn').classList.remove('active');
  document.getElementById('hair-wheat-btn').classList.remove('active');
  document.getElementById('hair-crystal-btn').classList.remove('active');
  
  document.getElementById(`hair-${type}-btn`).classList.add('active');
  
  console.log('Hair type set to:', type);
};

// NEW: Hair texture loading
const hairTextureInput = document.getElementById('hair-texture-input');
if (hairTextureInput) {
  hairTextureInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      event.target.value = '';
      return;
    }
    
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(URL.createObjectURL(file), (texture) => {
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      texture.encoding = THREE.sRGBEncoding;
      
      // Dispose old texture
      if (hairParticleSystem.texture) {
        hairParticleSystem.texture.dispose();
      }
      
      hairParticleSystem.texture = texture;
      
      // Show preview
      const preview = document.getElementById('hair-texture-preview');
      if (preview) {
        preview.style.backgroundImage = `url(${URL.createObjectURL(file)})`;
        preview.style.display = 'block';
      }
      
      // Update existing hair particles
      hairParticleSystem.meshes.forEach(hair => {
        if (hair.material) {
          hair.material.map = texture;
          hair.material.needsUpdate = true;
        }
      });
      
      console.log('Hair texture loaded');
    }, undefined, (error) => {
      console.error('Error loading hair texture:', error);
      alert('Failed to load texture');
    });
    
    event.target.value = '';
  });
}

// NEW: Remove hair texture
window.removeHairTexture = function() {
  if (hairParticleSystem.texture) {
    hairParticleSystem.texture.dispose();
    hairParticleSystem.texture = null;
  }
  
  const preview = document.getElementById('hair-texture-preview');
  if (preview) {
    preview.style.display = 'none';
  }
  
  // Update existing hair particles
  hairParticleSystem.meshes.forEach(hair => {
    if (hair.material) {
      hair.material.map = null;
      hair.material.needsUpdate = true;
    }
  });
  
  console.log('Hair texture removed');
};

// NEW: Reset hair transform
window.resetHairTransform = function() {
  hairParticleSystem.rotationX = 0;
  hairParticleSystem.rotationY = 0;
  hairParticleSystem.rotationZ = 0;
  hairParticleSystem.offsetY = 0;
  
  document.getElementById('hair-rot-x-slider').value = 0;
  document.getElementById('hair-rot-y-slider').value = 0;
  document.getElementById('hair-rot-z-slider').value = 0;
  document.getElementById('hair-offset-y-slider').value = 0;
  
  document.getElementById('hair-rot-x-value').textContent = '0¬∞';
  document.getElementById('hair-rot-y-value').textContent = '0¬∞';
  document.getElementById('hair-rot-z-value').textContent = '0¬∞';
  document.getElementById('hair-offset-y-value').textContent = '0.0';
  
  // Update existing hair particles
  hairParticleSystem.meshes.forEach(hair => {
    applyHairTransform(hair);
  });
};

// NEW: Apply transform to hair particle
function applyHairTransform(hair) {
  const rotX = THREE.MathUtils.degToRad(hairParticleSystem.rotationX);
  const rotY = THREE.MathUtils.degToRad(hairParticleSystem.rotationY);
  const rotZ = THREE.MathUtils.degToRad(hairParticleSystem.rotationZ);
  
  // Apply base rotation plus additional rotation
  hair.rotation.x = (hair.userData.baseRotationX || 0) + rotX;
  hair.rotation.y = (hair.userData.baseRotationY || 0) + rotY;
  hair.rotation.z = (hair.userData.baseRotationZ || 0) + rotZ;
  
  // Apply Y offset
  hair.position.y = hair.userData.baseY + hairParticleSystem.offsetY;
}

// Toggle hair paint mode
window.toggleHairPaintMode = function() {
  hairParticleSystem.enabled = !hairParticleSystem.enabled;
  
  const btn = document.getElementById('toggle-hair-paint-btn');
  if (hairParticleSystem.enabled) {
    btn.textContent = 'Disable Hair Paint';
    btn.style.background = '#4CAF50';
    orbitControls.enabled = false;
    renderer.domElement.style.cursor = 'crosshair';
  } else {
    btn.textContent = 'Enable Hair Paint';
    btn.style.background = '';
    orbitControls.enabled = true;
    renderer.domElement.style.cursor = 'default';
  }
};

// Paint hair particles on terrain
function paintHairParticles(intersectionPoint) {
  if (!groundPlane || !hairParticleSystem.enabled) return;
  
  const numParticles = hairParticleSystem.density;
  const radius = hairParticleSystem.paintRadius;
  
  for (let i = 0; i < numParticles; i++) {
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * radius;
    const x = intersectionPoint.x + Math.cos(angle) * distance;
    const z = intersectionPoint.z + Math.sin(angle) * distance;
    
    const y = getTerrainHeightAt(x, z);
    
    createHairParticle(x, y, z);
  }
  
  updateHairCount();
}

// Create individual hair particle with texture and transform support
function createHairParticle(x, y, z) {
  let geometry, material;
  
  const hairLength = hairParticleSystem.length * (0.8 + Math.random() * 0.4);
  const hairThickness = hairParticleSystem.thickness * (0.8 + Math.random() * 0.4);
  
  // Color with variation
  const baseColor = hairParticleSystem.color.clone();
  const variation = hairParticleSystem.colorVariation;
  baseColor.offsetHSL(
    (Math.random() - 0.5) * variation,
    (Math.random() - 0.5) * variation,
    (Math.random() - 0.5) * variation
  );
  
  switch(hairParticleSystem.type) {
    case 'grass':
      geometry = new THREE.PlaneGeometry(hairThickness * 2, hairLength, 1, 4); // Changed to plane for better texture
      break;
    case 'fur':
      geometry = new THREE.CylinderGeometry(hairThickness, hairThickness * 0.3, hairLength, 4, 1);
      break;
    case 'spikes':
      geometry = new THREE.ConeGeometry(hairThickness * 2, hairLength, 6);
      break;
    case 'wheat':
      geometry = new THREE.PlaneGeometry(hairThickness, hairLength * 0.7, 1, 3);
      break;
    case 'crystal':
      geometry = new THREE.ConeGeometry(hairThickness * 3, hairLength, 6, 1);
      break;
  }
  
  // Create material with texture support
  material = new THREE.MeshStandardMaterial({
    color: baseColor,
    roughness: 0.9,
    metalness: hairParticleSystem.type === 'crystal' ? 0.3 : 0.0,
    side: THREE.DoubleSide,
    transparent: hairParticleSystem.texture ? true : false,
    alphaTest: hairParticleSystem.texture ? 0.5 : 0,
    map: hairParticleSystem.texture ? hairParticleSystem.texture.clone() : null
  });
  
  if (material.map) {
    material.map.needsUpdate = true;
  }
  
  const hair = new THREE.Mesh(geometry, material);
  
  // Store base position
  hair.userData.baseY = y + hairLength / 2;
  hair.position.set(x, hair.userData.baseY + hairParticleSystem.offsetY, z);
  
  // Random base rotation
  const baseRotX = (Math.random() - 0.5) * 0.2;
  const baseRotY = Math.random() * Math.PI * 2;
  const baseRotZ = (Math.random() - 0.5) * 0.2;
  
  hair.userData.baseRotationX = baseRotX;
  hair.userData.baseRotationY = baseRotY;
  hair.userData.baseRotationZ = baseRotZ;
  
  // Apply transform
  applyHairTransform(hair);
  
  // Store original values for wind animation
  hair.userData.isHairParticle = true;
  hair.userData.originalRotationX = hair.rotation.x;
  hair.userData.originalRotationZ = hair.rotation.z;
  hair.userData.windPhase = Math.random() * Math.PI * 2;
  hair.userData.windSpeed = 0.5 + Math.random() * 0.5;
  
  hair.castShadow = true;
  hair.receiveShadow = true;
  
  scene.add(hair);
  hairParticleSystem.meshes.push(hair);
}

// Get terrain height at specific position
function getTerrainHeightAt(x, z) {
  if (!groundPlane) return 0;
  
  const geometry = groundPlane.geometry;
  const positionAttribute = geometry.attributes.position;
  
  let closestY = 0;
  let minDist = Infinity;
  
  for (let i = 0; i < positionAttribute.count; i++) {
    const vx = positionAttribute.array[i * 3];
    const vy = positionAttribute.array[i * 3 + 1];
    const vz = positionAttribute.array[i * 3 + 2];
    
    const dist = Math.sqrt((vx - x) ** 2 + (vy - z) ** 2);
    
    if (dist < minDist) {
      minDist = dist;
      closestY = vz;
    }
  }
  
  return groundPlane.position.y + closestY;
}

// Clear all hair particles
window.clearHairParticles = function() {
  hairParticleSystem.meshes.forEach(hair => {
    scene.remove(hair);
    if (hair.geometry) hair.geometry.dispose();
    if (hair.material) {
      if (hair.material.map) hair.material.map.dispose();
      hair.material.dispose();
    }
  });
  hairParticleSystem.meshes = [];
  updateHairCount();
};

// Toggle hair visibility
window.toggleHairVisibility = function() {
  hairParticleSystem.visible = !hairParticleSystem.visible;
  
  hairParticleSystem.meshes.forEach(hair => {
    hair.visible = hairParticleSystem.visible;
  });
  
  const btn = document.getElementById('toggle-hair-vis-btn');
  btn.textContent = hairParticleSystem.visible ? 'Hide Hair' : 'Show Hair';
};

// Update hair count display
function updateHairCount() {
  const display = document.getElementById('hair-count-display');
  if (display) {
    display.textContent = hairParticleSystem.meshes.length;
  }
}

// Hair painting mouse events
renderer.domElement.addEventListener('mousedown', (e) => {
  if (hairParticleSystem.enabled && e.button === 0) {
    isHairPainting = true;
    paintHairAtMouse(e);
  }
});

renderer.domElement.addEventListener('mousemove', (e) => {
  if (isHairPainting) {
    paintHairAtMouse(e);
  }
});

renderer.domElement.addEventListener('mouseup', () => {
  isHairPainting = false;
});

function paintHairAtMouse(event) {
  let clientX, clientY;
  
  // Handle both mouse and touch events
  if (event.touches && event.touches.length > 0) {
    clientX = event.touches[0].clientX;
    clientY = event.touches[0].clientY;
  } else {
    clientX = event.clientX;
    clientY = event.clientY;
  }
  
  mouse.x = (clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(clientY / window.innerHeight) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  
  if (groundPlane) {
    const intersects = raycaster.intersectObject(groundPlane);
    if (intersects.length > 0) {
      paintHairParticles(intersects[0].point);
    }
  }
}

// Update mouse listeners to also handle touch
renderer.domElement.addEventListener('touchstart', (e) => {
  if (hairParticleSystem.enabled && e.touches.length === 1) {
    e.preventDefault();
    isHairPainting = true;
    paintHairAtMouse(e);
  }
});

renderer.domElement.addEventListener('touchmove', (e) => {
  if (isHairPainting && e.touches.length === 1) {
    e.preventDefault();
    paintHairAtMouse(e);
  }
});

renderer.domElement.addEventListener('touchend', () => {
  isHairPainting = false;
});


// Wind animation for hair
function animateHairWind() {
  const time = Date.now() * 0.001;
  const windStrength = hairParticleSystem.windStrength;
  
  hairParticleSystem.meshes.forEach(hair => {
    if (!hair.userData.isHairParticle) return;
    
    const phase = hair.userData.windPhase;
    const speed = hair.userData.windSpeed;
    
    const windX = Math.sin(time * speed + phase) * windStrength * 0.3;
    const windZ = Math.cos(time * speed * 0.7 + phase) * windStrength * 0.3;
    
    hair.rotation.x = hair.userData.originalRotationX + windX;
    hair.rotation.z = hair.userData.originalRotationZ + windZ;
  });
}

// NEW: Hair transform sliders
const hairTransformSliders = {
  'hair-rot-x-slider': (v) => {
    hairParticleSystem.rotationX = parseInt(v);
    document.getElementById('hair-rot-x-value').textContent = v + '¬∞';
    hairParticleSystem.meshes.forEach(hair => applyHairTransform(hair));
  },
  'hair-rot-y-slider': (v) => {
    hairParticleSystem.rotationY = parseInt(v);
    document.getElementById('hair-rot-y-value').textContent = v + '¬∞';
    hairParticleSystem.meshes.forEach(hair => applyHairTransform(hair));
  },
  'hair-rot-z-slider': (v) => {
    hairParticleSystem.rotationZ = parseInt(v);
    document.getElementById('hair-rot-z-value').textContent = v + '¬∞';
    hairParticleSystem.meshes.forEach(hair => applyHairTransform(hair));
  },
  'hair-offset-y-slider': (v) => {
    hairParticleSystem.offsetY = parseFloat(v);
    document.getElementById('hair-offset-y-value').textContent = parseFloat(v).toFixed(1);
    hairParticleSystem.meshes.forEach(hair => applyHairTransform(hair));
  }
};

// Hair slider event listeners
const hairSliders = {
  'hair-density-slider': (v) => { hairParticleSystem.density = parseInt(v); },
  'hair-length-slider': (v) => { hairParticleSystem.length = parseFloat(v); },
  'hair-thickness-slider': (v) => { hairParticleSystem.thickness = parseFloat(v); },
  'hair-radius-slider': (v) => { hairParticleSystem.paintRadius = parseFloat(v); },
  'hair-wind-slider': (v) => { hairParticleSystem.windStrength = parseFloat(v); },
  'hair-color-var-slider': (v) => { hairParticleSystem.colorVariation = parseFloat(v); },
  ...hairTransformSliders
};

Object.keys(hairSliders).forEach(sliderId => {
  const slider = document.getElementById(sliderId);
  if (slider) {
    slider.addEventListener('input', (e) => {
      const value = e.target.value;
      hairSliders[sliderId](value);
      
      const displayId = sliderId.replace('-slider', '-value');
      const display = document.getElementById(displayId);
      if (display && !hairTransformSliders[sliderId]) {
        display.textContent = sliderId.includes('density') ? value : parseFloat(value).toFixed(2);
      }
    });
  }
});

// Hair color picker
const hairColorPicker = document.getElementById('hair-color-picker');
if (hairColorPicker) {
  hairColorPicker.addEventListener('input', (e) => {
    hairParticleSystem.color.set(e.target.value);
  });
}


// ============= MODEL LOADING =============

function loadModel(file, offsetIndex = 0) {
  const fileName = file.name.toLowerCase();
  let loader;

  if (fileName.endsWith('.fbx')) {
    loader = new THREE.FBXLoader();
  } else if (fileName.endsWith('.stl')) {
    loader = new THREE.STLLoader();
  } else if (fileName.endsWith('.gltf') || fileName.endsWith('.glb')) {
    loader = new THREE.GLTFLoader();
  } else if (fileName.endsWith('.obj')) {
    loader = new THREE.OBJLoader();
  } else {
    alert('Unsupported file format: ' + fileName);
    return;
  }

  loader.load(URL.createObjectURL(file), (loadedObject) => {
    let object;
    
    if (loadedObject.scene) {
      object = loadedObject.scene;
    } else if (loadedObject.geometry) {
      const material = new THREE.MeshBasicMaterial({ 
        color: 0x808080,
        roughness: 0.7,
        metalness: 0.0,
        toneMapped: false,
      });
      object = new THREE.Mesh(loadedObject.geometry, material);
    } else {
      object = loadedObject;
    }

    object.traverse((child) => {
  if (child.isMesh) {
    child.castShadow = true;
    child.receiveShadow = false;
    
    if (child.material) {
      // Always convert to MeshBasicMaterial for unlit rendering
      const oldMaterial = child.material;
      
      child.material = new THREE.MeshBasicMaterial({
        map: oldMaterial.map || null,
        color: oldMaterial.color || new THREE.Color(0xffffff),
        transparent: oldMaterial.transparent || false,
        opacity: oldMaterial.opacity !== undefined ? oldMaterial.opacity : 1.0,
        side: oldMaterial.side || THREE.FrontSide,
        alphaTest: oldMaterial.alphaTest || 0,
        toneMapped: false
      });
      
      if (child.material.map) {
        child.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
        child.material.map.encoding = THREE.sRGBEncoding;
      }
      
      // Dispose old material
      if (oldMaterial !== child.material) {
        oldMaterial.dispose();
      }
    } else {
      child.material = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        toneMapped: false
      });
    }
  }
});

    const box = new THREE.Box3().setFromObject(object);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    
    object.position.sub(center);
    
    const maxDimension = Math.max(size.x, size.y, size.z);
    if (maxDimension > 0) {
      const scale = 2 / maxDimension;
      object.scale.set(scale, scale, scale);
    }

    object.position.x += offsetIndex * 3;
    object.position.y = 0;

    modelCounter++;
    object.userData = {
      id: modelCounter,
      name: file.name,
      originalName: file.name,
      bones: []
    };

    detectBones(object);

    scene.add(object);
    models.push(object);
    selectModel(object);
    updateObjectList();
    
    undoManager.pushState();
    
    console.log('Model loaded:', object);
    
  }, undefined, (error) => {
    console.error('Error loading model:', error);
    alert('Error loading ' + file.name);
  });
}

// ============= BONE DETECTION =============

function detectBones(object) {
  const detectedBones = [];
  
  object.traverse((child) => {
    if (child.isBone) {
      detectedBones.push(child);
      child.userData.originalRotation = child.rotation.clone();
      child.userData.originalPosition = child.position.clone();
    }
  });

  object.userData.bones = detectedBones;
  
  if (detectedBones.length > 0) {
    console.log(`Detected $${detectedBones.length} bones in$$ {object.userData.name}`);
  }

  updateBoneList();
}
// Add this after your existing bone detection code

// ============= ENHANCED BONE VISUALIZATION & MANIPULATION =============

let boneVisualHelpers = [];
let boneEditMode = false;
let selectedBoneEnd = null; // 'start' or 'end'

// Bone visualization settings
const boneVisualization = {
  showBones: false,
  boneColor: 0x00ff00,
  selectedBoneColor: 0xffff00,
  boneThickness: 0.05,
  jointSize: 0.1
};

// Enhanced bone structure
class EnhancedBone {
  constructor(bone, parentModel) {
    this.bone = bone;
    this.parentModel = parentModel;
    this.name = bone.name || 'Unnamed Bone';
    this.visualHelper = null;
    this.startJoint = null;
    this.endJoint = null;
    this.children = [];
    this.parent = null;
  }
}

// Store enhanced bone data
let enhancedBones = new Map();

// Create visual representation of bones
function createBoneVisualHelper(enhancedBone) {
  const bone = enhancedBone.bone;
  
  // Remove old helper if exists
  if (enhancedBone.visualHelper) {
    scene.remove(enhancedBone.visualHelper);
    if (enhancedBone.visualHelper.geometry) enhancedBone.visualHelper.geometry.dispose();
    if (enhancedBone.visualHelper.material) enhancedBone.visualHelper.material.dispose();
  }
  
  const group = new THREE.Group();
  
  // Get bone world positions
  const startPos = new THREE.Vector3();
  const endPos = new THREE.Vector3();
  
  bone.getWorldPosition(startPos);
  
  // Find end position (use first child bone or extend from parent)
  if (bone.children.length > 0 && bone.children[0].isBone) {
    bone.children[0].getWorldPosition(endPos);
  } else {
    // No child, create end point based on parent direction
    endPos.copy(startPos);
    endPos.y += 0.5; // Default length
  }
  
  // Create bone cylinder connecting start to end
  const direction = new THREE.Vector3().subVectors(endPos, startPos);
  const length = direction.length();
  
  if (length > 0.001) {
    const boneGeometry = new THREE.CylinderGeometry(
      boneVisualization.boneThickness,
      boneVisualization.boneThickness,
      length,
      8
    );
    
    const boneMaterial = new THREE.MeshBasicMaterial({
      color: boneVisualization.boneColor,
      transparent: true,
      opacity: 0.7,
      depthTest: true,
      depthWrite: false
    });
    
    const boneMesh = new THREE.Mesh(boneGeometry, boneMaterial);
    boneMesh.userData.isBoneHelper = true;
    boneMesh.userData.enhancedBone = enhancedBone;
    
    // Position and orient the cylinder
    const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
    boneMesh.position.copy(midpoint);
    
    // Orient cylinder to point from start to end
    boneMesh.quaternion.setFromUnitVectors(
      new THREE.Vector3(0, 1, 0),
      direction.normalize()
    );
    
    group.add(boneMesh);
  }
  
  // Create start joint sphere
  const startJointGeometry = new THREE.SphereGeometry(boneVisualization.jointSize, 16, 16);
  const startJointMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    transparent: true,
    opacity: 0.8
  });
  const startJoint = new THREE.Mesh(startJointGeometry, startJointMaterial);
  startJoint.position.copy(startPos);
  startJoint.userData.isBoneJoint = true;
  startJoint.userData.jointType = 'start';
  startJoint.userData.enhancedBone = enhancedBone;
  group.add(startJoint);
  enhancedBone.startJoint = startJoint;
  
  // Create end joint sphere
  const endJointGeometry = new THREE.SphereGeometry(boneVisualization.jointSize, 16, 16);
  const endJointMaterial = new THREE.MeshBasicMaterial({
    color: 0x0000ff,
    transparent: true,
    opacity: 0.8
  });
  const endJoint = new THREE.Mesh(endJointGeometry, endJointMaterial);
  endJoint.position.copy(endPos);
  endJoint.userData.isBoneJoint = true;
  endJoint.userData.jointType = 'end';
  endJoint.userData.enhancedBone = enhancedBone;
  group.add(endJoint);
  enhancedBone.endJoint = endJoint;
  
  enhancedBone.visualHelper = group;
  group.userData.iseBoneVisualHelper = true;
  
  if (boneVisualization.showBones) {
    scene.add(group);
  }
  
  boneVisualHelpers.push(group);
  
  return group;
}

// Toggle bone visualization
window.toggleBoneVisualization = function() {
  boneVisualization.showBones = !boneVisualization.showBones;
  
  boneVisualHelpers.forEach(helper => {
    if (boneVisualization.showBones) {
      scene.add(helper);
    } else {
      scene.remove(helper);
    }
  });
  
  const btn = document.getElementById('toggle-bone-vis-btn');
  if (btn) {
    btn.textContent = boneVisualization.showBones ? 'Hide Bone Geometry' : 'Show Bone Geometry';
    btn.style.backgroundColor = boneVisualization.showBones ? '#4CAF50' : '';
  }
};

// Enhanced bone detection with visualization
function detectBonesEnhanced(object) {
  const detectedBones = [];
  enhancedBones.clear();
  
  // Clear old visual helpers
  boneVisualHelpers.forEach(helper => {
    scene.remove(helper);
    helper.traverse(child => {
      if (child.geometry) child.geometry.dispose();
      if (child.material) child.material.dispose();
    });
  });
  boneVisualHelpers = [];
  
  object.traverse((child) => {
    if (child.isBone) {
      const enhanced = new EnhancedBone(child, object);
      enhancedBones.set(child.uuid, enhanced);
      detectedBones.push(child);
      
      child.userData.originalRotation = child.rotation.clone();
      child.userData.originalPosition = child.position.clone();
      child.userData.enhancedBone = enhanced;
      
      // Create visual helper
      createBoneVisualHelper(enhanced);
    }
  });
  
  // Build parent-child relationships
  enhancedBones.forEach((enhanced) => {
    const bone = enhanced.bone;
    if (bone.parent && bone.parent.isBone) {
      const parentEnhanced = enhancedBones.get(bone.parent.uuid);
      if (parentEnhanced) {
        enhanced.parent = parentEnhanced;
        parentEnhanced.children.push(enhanced);
      }
    }
  });
  
  object.userData.bones = detectedBones;
  object.userData.enhancedBones = Array.from(enhancedBones.values());
  
  if (detectedBones.length > 0) {
    console.log(`‚úì Detected $${detectedBones.length} bones with visualization in$$ {object.userData.name}`);
  }
  
  updateBoneListEnhanced();
}

// Enhanced bone list with naming and hierarchy
function updateBoneListEnhanced() {
  const container = document.getElementById('bone-list');
  if (!container) return;
  
  if (!selectedModel || !selectedModel.userData.enhancedBones || selectedModel.userData.enhancedBones.length === 0) {
    container.innerHTML = '<p style="font-size: 11px; color: #666;">No bones detected</p>';
    return;
  }
  
  container.innerHTML = '';
  
  // Build hierarchy display
  const rootBones = selectedModel.userData.enhancedBones.filter(eb => !eb.parent);
  
  function addBoneToList(enhancedBone, indent = 0) {
    const div = document.createElement('div');
    div.className = 'bone-item';
    div.style.paddingLeft = `${indent * 15}px`;
    
    if (enhancedBone.bone === selectedBone) {
      div.classList.add('selected');
    }
    
    const nameSpan = document.createElement('span');
    nameSpan.textContent = enhancedBone.name;
    nameSpan.style.cursor = 'pointer';
    nameSpan.style.flexGrow = '1';
    
    const renameBtn = document.createElement('button');
    renameBtn.textContent = '‚úé';
    renameBtn.title = 'Rename bone';
    renameBtn.style.marginLeft = '5px';
    renameBtn.style.padding = '2px 6px';
    renameBtn.style.fontSize = '12px';
    
    renameBtn.onclick = (e) => {
      e.stopPropagation();
      renameBone(enhancedBone);
    };
    
    div.appendChild(nameSpan);
    div.appendChild(renameBtn);
    
    nameSpan.addEventListener('click', () => {
      selectBoneEnhanced(enhancedBone);
    });
    
    container.appendChild(div);
    
    // Add children recursively
    enhancedBone.children.forEach(child => {
      addBoneToList(child, indent + 1);
    });
  }
  
  rootBones.forEach(bone => addBoneToList(bone));
}

// Rename bone function
function renameBone(enhancedBone) {
  const newName = prompt('Enter new bone name:', enhancedBone.name);
  if (newName && newName.trim()) {
    enhancedBone.name = newName.trim();
    enhancedBone.bone.name = newName.trim();
    updateBoneListEnhanced();
    
    const boneName = document.getElementById('selected-bone-name');
    if (boneName && selectedBone === enhancedBone.bone) {
      boneName.textContent = newName.trim();
    }
  }
}

// Select bone with enhanced features
function selectBoneEnhanced(enhancedBone) {
  selectedBone = enhancedBone.bone;
  selectedBoneEnd = null;
  
  // Update visual helpers
  boneVisualHelpers.forEach(helper => {
    helper.traverse(child => {
      if (child.material && child.material.color) {
        if (child.userData.enhancedBone === enhancedBone) {
          child.material.color.setHex(boneVisualization.selectedBoneColor);
        } else {
          if (child.userData.isBoneHelper) {
            child.material.color.setHex(boneVisualization.boneColor);
          } else if (child.userData.isBoneJoint) {
            child.material.color.setHex(child.userData.jointType === 'start' ? 0xff0000 : 0x0000ff);
          }
        }
      }
    });
  });
  
  updateBoneListEnhanced();
  
  const boneControls = document.getElementById('bone-transform-controls');
  const boneName = document.getElementById('selected-bone-name');
  
  if (boneControls) boneControls.style.display = 'block';
  if (boneName) boneName.textContent = enhancedBone.name;
  
  // Update bone info panel
  updateBoneInfoPanel(enhancedBone);
  
  // Update sliders
  const rotation = enhancedBone.bone.rotation;
  
  const rotX = document.getElementById('bone-rot-x');
  const rotY = document.getElementById('bone-rot-y');
  const rotZ = document.getElementById('bone-rot-z');
  
  if (rotX) rotX.value = THREE.MathUtils.radToDeg(rotation.x);
  if (rotY) rotY.value = THREE.MathUtils.radToDeg(rotation.y);
  if (rotZ) rotZ.value = THREE.MathUtils.radToDeg(rotation.z);
  
  if (document.getElementById('bone-rot-x-value')) {
    document.getElementById('bone-rot-x-value').textContent = Math.round(THREE.MathUtils.radToDeg(rotation.x)) + '¬∞';
  }
  if (document.getElementById('bone-rot-y-value')) {
    document.getElementById('bone-rot-y-value').textContent = Math.round(THREE.MathUtils.radToDeg(rotation.y)) + '¬∞';
  }
  if (document.getElementById('bone-rot-z-value')) {
    document.getElementById('bone-rot-z-value').textContent = Math.round(THREE.MathUtils.radToDeg(rotation.z)) + '¬∞';
  }
}

// Update bone info panel
function updateBoneInfoPanel(enhancedBone) {
  let infoPanelHTML = `
    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px;">
      <strong>${enhancedBone.name}</strong><br>
      Parent: ${enhancedBone.parent ? enhancedBone.parent.name : 'None (Root)'}<br>
      Children: ${enhancedBone.children.length}<br>
      <button onclick="window.extrudeBone('start')" style="margin-top: 5px; width: 48%; font-size: 10px;">Extrude Start</button>
      <button onclick="window.extrudeBone('end')" style="width: 48%; font-size: 10px;">Extrude End</button>
    </div>
  `;
  
  const infoContainer = document.getElementById('bone-info-panel');
  if (infoContainer) {
    infoContainer.innerHTML = infoPanelHTML;
  }
}

// Extrude bone from start or end
window.extrudeBone = function(endType) {
  if (!selectedBone) {
    alert('Please select a bone first');
    return;
  }
  
  const enhancedBone = enhancedBones.get(selectedBone.uuid);
  if (!enhancedBone) return;
  
  // Create new bone
  const newBone = new THREE.Bone();
  newBone.name = `${enhancedBone.name}_extruded`;
  
  if (endType === 'end') {
    // Add as child to current bone
    selectedBone.add(newBone);
    newBone.position.set(0, 0.5, 0); // Default offset
  } else {
    // Add as parent (more complex - insert between current parent and bone)
    const currentParent = selectedBone.parent;
    
    if (currentParent) {
      // Remove bone from current parent
      currentParent.remove(selectedBone);
      // Add new bone to current parent
      currentParent.add(newBone);
      // Add selected bone to new bone
      newBone.add(selectedBone);
      newBone.position.copy(selectedBone.position);
      selectedBone.position.set(0, 0.5, 0);
    } else {
      // Current bone is root - make new bone the parent
      const model = enhancedBone.parentModel;
      model.add(newBone);
      model.remove(selectedBone);
      newBone.add(selectedBone);
      newBone.position.copy(selectedBone.position);
      selectedBone.position.set(0, 0.5, 0);
    }
  }
  
  // Re-detect bones to update visualization
  detectBonesEnhanced(enhancedBone.parentModel);
  
  console.log(`‚úì Extruded bone from ${endType}:`, newBone.name);
  undoManager.pushState();
};

// Update the original detectBones to use enhanced version
const originalDetectBones = detectBones;
detectBones = function(object) {
  detectBonesEnhanced(object);
};

// Update bone visual helpers in animation loop
function updateBoneVisualHelpers() {
  enhancedBones.forEach(enhancedBone => {
    if (enhancedBone.visualHelper && boneVisualization.showBones) {
      // Update positions based on bone world transforms
      const bone = enhancedBone.bone;
      const startPos = new THREE.Vector3();
      const endPos = new THREE.Vector3();
      
      bone.getWorldPosition(startPos);
      
      if (bone.children.length > 0 && bone.children[0].isBone) {
        bone.children[0].getWorldPosition(endPos);
      } else {
        endPos.copy(startPos);
        endPos.y += 0.5;
      }
      
      // Update joint positions
      if (enhancedBone.startJoint) {
        enhancedBone.startJoint.position.copy(startPos);
      }
      if (enhancedBone.endJoint) {
        enhancedBone.endJoint.position.copy(endPos);
      }
      
      // Update bone cylinder
      enhancedBone.visualHelper.children.forEach(child => {
        if (child.userData.isBoneHelper) {
          const direction = new THREE.Vector3().subVectors(endPos, startPos);
          const length = direction.length();
          
          if (length > 0.001) {
            const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
            child.position.copy(midpoint);
            child.quaternion.setFromUnitVectors(
              new THREE.Vector3(0, 1, 0),
              direction.normalize()
            );
            child.scale.y = length / 1; // Adjust scale
          }
        }
      });
    }
  });
}

// Add bone info panel to HTML (add this to your bone-controls panel)
const boneControlsPanel = document.getElementById('bone-controls');
if (boneControlsPanel) {
  const boneInfoDiv = document.createElement('div');
  boneInfoDiv.id = 'bone-info-panel';
  boneControlsPanel.querySelector('.panel-content').appendChild(boneInfoDiv);
}

// Make sure to call updateBoneVisualHelpers in your animation loop

function updateBoneList() {
  const container = document.getElementById('bone-list');
  if (!container) return;
  
  if (!selectedModel || !selectedModel.userData.bones || selectedModel.userData.bones.length === 0) {
    container.innerHTML = '<p style="font-size: 11px; color: #666;">No bones detected</p>';
    return;
  }

  container.innerHTML = '';
  selectedModel.userData.bones.forEach((bone, index) => {
    const div = document.createElement('div');
    div.className = 'bone-item';
    if (bone === selectedBone) {
      div.classList.add('selected');
    }
    
    const boneName = bone.name || `Bone ${index + 1}`;
    div.textContent = boneName;
    
    div.addEventListener('click', () => {
      selectBone(bone);
    });
    
    container.appendChild(div);
  });
}

function selectBone(bone) {
  selectedBone = bone;
  updateBoneList();
  
  const boneControls = document.getElementById('bone-transform-controls');
  const boneName = document.getElementById('selected-bone-name');
  
  if (boneControls) boneControls.style.display = 'block';
  if (boneName) boneName.textContent = bone.name || 'Unnamed Bone';
  
  const rotation = bone.rotation;
  
  const rotX = document.getElementById('bone-rot-x');
  const rotY = document.getElementById('bone-rot-y');
  const rotZ = document.getElementById('bone-rot-z');
  const rotXVal = document.getElementById('bone-rot-x-value');
  const rotYVal = document.getElementById('bone-rot-y-value');
  const rotZVal = document.getElementById('bone-rot-z-value');
  
  if (rotX) rotX.value = THREE.MathUtils.radToDeg(rotation.x);
  if (rotY) rotY.value = THREE.MathUtils.radToDeg(rotation.y);
  if (rotZ) rotZ.value = THREE.MathUtils.radToDeg(rotation.z);
  
  if (rotXVal) rotXVal.textContent = Math.round(THREE.MathUtils.radToDeg(rotation.x)) + '¬∞';
  if (rotYVal) rotYVal.textContent = Math.round(THREE.MathUtils.radToDeg(rotation.y)) + '¬∞';
  if (rotZVal) rotZVal.textContent = Math.round(THREE.MathUtils.radToDeg(rotation.z)) + '¬∞';
}

// ============= BONE CONTROLS =============

// ============= BONE CONTROLS =============

// ============= PS2 ANALOG STICK CONTROLS =============

let isDraggingLeft = false;
let isDraggingRight = false;

// Bone rotation sliders
function initBoneSliders() {
  const rotX = document.getElementById('bone-rot-x');
  const rotY = document.getElementById('bone-rot-y');
  const rotZ = document.getElementById('bone-rot-z');
  
  if (rotX) {
    rotX.addEventListener('input', (e) => {
      if (!selectedBone) return;
      const value = parseFloat(e.target.value);
      selectedBone.rotation.x = THREE.MathUtils.degToRad(value);
      document.getElementById('bone-rot-x-value').textContent = Math.round(value) + '¬∞';
    });
  }
  
  if (rotY) {
    rotY.addEventListener('input', (e) => {
      if (!selectedBone) return;
      const value = parseFloat(e.target.value);
      selectedBone.rotation.y = THREE.MathUtils.degToRad(value);
      document.getElementById('bone-rot-y-value').textContent = Math.round(value) + '¬∞';
    });
  }
  
  if (rotZ) {
    rotZ.addEventListener('input', (e) => {
      if (!selectedBone) return;
      const value = parseFloat(e.target.value);
      selectedBone.rotation.z = THREE.MathUtils.degToRad(value);
      document.getElementById('bone-rot-z-value').textContent = Math.round(value) + '¬∞';
    });
  }
  
  // Reset button
  const resetBtn = document.getElementById('reset-bone-btn');
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      if (!selectedBone) return;
      
      if (selectedBone.userData.originalRotation) {
        selectedBone.rotation.copy(selectedBone.userData.originalRotation);
      } else {
        selectedBone.rotation.set(0, 0, 0);
      }
      
      if (rotX) rotX.value = 0;
      if (rotY) rotY.value = 0;
      if (rotZ) rotZ.value = 0;
      
      document.getElementById('bone-rot-x-value').textContent = '0¬∞';
      document.getElementById('bone-rot-y-value').textContent = '0¬∞';
      document.getElementById('bone-rot-z-value').textContent = '0¬∞';
    });
  }
}

// Call this instead of initPS2AnalogSticks()
document.addEventListener('DOMContentLoaded', () => {
  initBoneSliders();
});

// Reset button
const resetBoneBtn = document.getElementById('reset-bone-btn');
if (resetBoneBtn) {
  resetBoneBtn.addEventListener('click', () => {
    if (!selectedBone) return;
    
    // Reset rotation
    if (selectedBone.userData.originalRotation) {
      selectedBone.rotation.copy(selectedBone.userData.originalRotation);
    } else {
      selectedBone.rotation.set(0, 0, 0);
    }
    
    // Reset stick positions
    const leftThumb = document.getElementById('left-thumb');
    const rightThumb = document.getElementById('right-thumb');
    
    if (leftThumb) leftThumb.style.transform = 'translate(-50%, -50%)';
    if (rightThumb) rightThumb.style.transform = 'translate(-50%, -50%)';
    
    // Reset displays
    document.getElementById('rot-x-display').textContent = '0¬∞';
    document.getElementById('rot-y-display').textContent = '0¬∞';
    document.getElementById('rot-z-display').textContent = '0¬∞';
  });
}

// Toggle bones visibility
const toggleBonesBtn = document.getElementById('toggle-bones-btn');
if (toggleBonesBtn) {
  toggleBonesBtn.addEventListener('click', () => {
    showBones = !showBones;
    
    if (selectedModel && selectedModel.userData.bones) {
      selectedModel.userData.bones.forEach(bone => {
        bone.visible = showBones;
      });
    }
    
    toggleBonesBtn.textContent = showBones ? 'Hide Bones' : 'Show Bones';
  });
}

// Toggle bone helpers
const toggleBoneHelpersBtn = document.getElementById('toggle-bone-helpers-btn');
if (toggleBoneHelpersBtn) {
  toggleBoneHelpersBtn.addEventListener('click', () => {
    showBoneHelpers = !showBoneHelpers;
    
    boneHelpers.forEach(helper => {
      if (helper.parent) helper.parent.remove(helper);
    });
    boneHelpers = [];
    
    if (showBoneHelpers && selectedModel && selectedModel.userData.bones) {
      selectedModel.userData.bones.forEach(bone => {
        const helper = new THREE.AxesHelper(0.5);
        bone.add(helper);
        boneHelpers.push(helper);
      });
    }
    
    toggleBoneHelpersBtn.textContent = showBoneHelpers ? 'Hide Helpers' : 'Show Helpers';
  });
}

// Initialize PS2 analog sticks when DOM is ready
// IMPORTANT: Call this at the end of your script or in a DOMContentLoaded event


// OR if your script already runs after DOM loads, just call it directly:
// initPS2AnalogSticks();


// ============= TEXTURE CONTROLS =============

const groundTextureInput = document.getElementById('ground-texture-input');
if (groundTextureInput) {
  groundTextureInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file for ground texture');
      event.target.value = '';
      return;
    }
    
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(URL.createObjectURL(file), (texture) => {
      if (!groundPlane) {
        createGroundPlane();
      }
      
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(10, 10);
      
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = true;
      texture.encoding = THREE.sRGBEncoding;
      
      if (groundPlane.material.map) {
        groundPlane.material.map.dispose();
      }
      
      groundPlane.material.map = texture;
      groundPlane.material.color.setHex(0xffffff);
      groundPlane.material.toneMapped = false;
      groundPlane.material.needsUpdate = true;
      
      console.log('Ground texture applied');
    }, undefined, (error) => {
      console.error('Error loading ground texture:', error);
      alert('Failed to load ground texture');
    });
    
    event.target.value = '';
  });
}

const groundTileSlider = document.getElementById('ground-tile-slider');
if (groundTileSlider) {
  groundTileSlider.addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    const valueDisplay = document.getElementById('ground-tile-value');
    if (valueDisplay) valueDisplay.textContent = value.toFixed(1) + 'x';
    
    if (groundPlane && groundPlane.material.map) {
      groundPlane.material.map.repeat.set(value, value);
    }
  });
}

const skyTextureInput = document.getElementById('sky-texture-input');
if (skyTextureInput) {
  skyTextureInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.type.startsWith('image/')) {
      alert('Please select an image file for sky texture');
      event.target.value = '';
      return;
    }

    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(URL.createObjectURL(file), (texture) => {
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      texture.minFilter = THREE.LinearMipmapLinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = true;
      texture.encoding = THREE.sRGBEncoding;
      
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(1, 2);
      
      if (skyTexture) {
        skyTexture.dispose();
      }
      skyTexture = texture;
      
      if (!skySphere) {
        createSkySphere();
      } else {
        if (skySphere.material.map) {
          skySphere.material.map.dispose();
        }
        skySphere.material.map = texture;
        skySphere.material.needsUpdate = true;
      }
      
      console.log('Sky texture applied');
    }, undefined, (error) => {
      console.error('Error loading sky texture:', error);
      alert('Failed to load sky texture');
    });

    event.target.value = '';
  });
}

const removeGroundTextureBtn = document.getElementById('remove-ground-texture');
if (removeGroundTextureBtn) {
  removeGroundTextureBtn.addEventListener('click', () => {
    if (groundPlane) {
      scene.remove(groundPlane);
      if (groundPlane.geometry) groundPlane.geometry.dispose();
      if (groundPlane.material) {
        if (groundPlane.material.map) groundPlane.material.map.dispose();
        groundPlane.material.dispose();
      }
      groundPlane = null;
    }
  });
}

const removeSkyTextureBtn = document.getElementById('remove-sky-texture');
if (removeSkyTextureBtn) {
  removeSkyTextureBtn.addEventListener('click', () => {
    scene.background = originalBackground;
    if (skySphere) {
      scene.remove(skySphere);
      if (skySphere.geometry) skySphere.geometry.dispose();
      if (skySphere.material) {
        if (skySphere.material.map) skySphere.material.map.dispose();
        skySphere.material.dispose();
      }
      skySphere = null;
    }
    if (skyTexture) {
      skyTexture.dispose();
      skyTexture = null;
    }
  });
}

const toggleGridBtn = document.getElementById('toggle-grid');
if (toggleGridBtn) {
  toggleGridBtn.addEventListener('click', () => {
    gridHelper.visible = !gridHelper.visible;
  });
}

const toggleSkySphereBtn = document.getElementById('toggle-sky-sphere');
if (toggleSkySphereBtn) {
  toggleSkySphereBtn.addEventListener('click', () => {
    if (skySphere) {
      scene.remove(skySphere);
      if (skySphere.geometry) skySphere.geometry.dispose();
      if (skySphere.material) {
        if (skySphere.material.map) skySphere.material.map.dispose();
        skySphere.material.dispose();
      }
      skySphere = null;
    } else if (skyTexture) {
      createSkySphere();
    } else {
      alert('Please load a sky texture first');
    }
  });
}

// ============= TEXTURE PLANE SYSTEM =============

function createTexturePlane(texture, name) {
  const geometry = new THREE.PlaneGeometry(2, 2);
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    side: THREE.DoubleSide,
    toneMapped: false,
    depthWrite: false
  });
  
  const plane = new THREE.Mesh(geometry, material);
  plane.position.set(0, 1, 0);
  
  texturePlaneCounter++;
  plane.userData = {
    id: texturePlaneCounter,
    name: name || `Texture ${texturePlaneCounter}`,
    isTexturePlane: true
  };
  
  scene.add(plane);
  texturePlanes.push(plane);
  updateTexturePlaneList();
  selectModel(plane);
  undoManager.pushState();
  
  return plane;
}

const extraTextureInput = document.getElementById('extra-texture-input');
if (extraTextureInput) {
  extraTextureInput.addEventListener('change', (event) => {
    const files = Array.from(event.target.files);
    
    files.forEach((file, index) => {
      if (!file.type.startsWith('image/')) {
        alert(`${file.name} is not an image file`);
        return;
      }
      
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(URL.createObjectURL(file), (texture) => {
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture.encoding = THREE.sRGBEncoding;
        
        createTexturePlane(texture, file.name);
      }, undefined, (error) => {
        console.error('Error loading texture:', error);
        alert(`Failed to load ${file.name}`);
      });
    });
    
    event.target.value = '';
  });
}

function updateTexturePlaneList() {
  const container = document.getElementById('texture-planes-container');
  if (!container) return;
  
  if (texturePlanes.length === 0) {
    container.innerHTML = '<p style="font-size: 11px; color: #666;">No texture planes</p>';
    return;
  }
  
  container.innerHTML = '';
  texturePlanes.forEach((plane) => {
    const div = document.createElement('div');
    div.className = 'object-item';
    if (plane === selectedModel) {
      div.classList.add('selected');
    }
    
    div.innerHTML = `
      <span>${plane.userData.name}</span>
      <button onclick="window.deleteTexturePlane(${plane.userData.id})" title="Delete">√ó</button>
    `;
    
    div.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON') {
        selectModel(plane);
      }
    });
    
    container.appendChild(div);
  });
}

window.deleteTexturePlane = function(planeId) {
  const planeIndex = texturePlanes.findIndex(p => p.userData.id === planeId);
  if (planeIndex !== -1) {
    const plane = texturePlanes[planeIndex];
    if (plane === selectedModel) {
      transformControls.detach();
      selectedModel = null;
    }
    
    if (plane.geometry) plane.geometry.dispose();
    if (plane.material) {
      if (plane.material.map) plane.material.map.dispose();
      plane.material.dispose();
    }
    
    scene.remove(plane);
    texturePlanes.splice(planeIndex, 1);
    updateTexturePlaneList();
    undoManager.pushState();
  }
};


window.deleteModel = function(modelId) {
  const modelIndex = models.findIndex(m => m.userData.id === modelId);
  if (modelIndex !== -1) {
    const model = models[modelIndex];
    
    // Detach if selected
    if (model === selectedModel) {
      transformControls.detach();
      selectedModel = null;
      selectedBone = null;
    }
    
    // Dispose resources
    model.traverse((child) => {
      if (child.geometry) child.geometry.dispose();
      if (child.material) {
        if (Array.isArray(child.material)) {
          child.material.forEach(mat => {
            if (mat.map) mat.map.dispose();
            if (mat.normalMap) mat.normalMap.dispose();
            if (mat.roughnessMap) mat.roughnessMap.dispose();
            if (mat.metalnessMap) mat.metalnessMap.dispose();
            mat.dispose();
          });
        } else {
          if (child.material.map) child.material.map.dispose();
          if (child.material.normalMap) child.material.normalMap.dispose();
          if (child.material.roughnessMap) child.material.roughnessMap.dispose();
          if (child.material.metalnessMap) child.material.metalnessMap.dispose();
          child.material.dispose();
        }
      }
    });
    
    // Remove from scene and array
    scene.remove(model);
    models.splice(modelIndex, 1);
    
    updateObjectList();
    updateBoneList();
    undoManager.pushState();
    
    console.log('Model deleted:', modelId);
  }
};

// ============= MODEL SELECTION =============

function selectModel(model) {
  if (selectedModel) {
    selectedModel.traverse((child) => {
      if (child.isMesh && child.material && child.material.emissive) {
        child.material.emissive.setHex(0x000000);
      }
    });
    transformControls.detach();
  }
  
  selectedModel = model;
  selectedBone = null;
  
  if (model) {
    model.traverse((child) => {
      if (child.isMesh && child.material && child.material.emissive) {
        child.material.emissive.setHex(0x444444);
      }
    });
    transformControls.attach(model);
    updateBoneList();
  } else {
    const boneControls = document.getElementById('bone-transform-controls');
    if (boneControls) boneControls.style.display = 'none';
    updateBoneList();
  }
  
  updateObjectList();
}

function onMouseClick(event) {
  if (event.target.closest('.panel')) return;
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(models, true);

  if (intersects.length > 0) {
    let clickedModel = intersects[0].object;
    
    if (clickedModel.userData.isGroundPlane || clickedModel.userData.isSkySphere) {
      return;
    }
    
    while (clickedModel.parent && !models.includes(clickedModel)) {
      clickedModel = clickedModel.parent;
    }
    
    if (models.includes(clickedModel)) {
      selectModel(clickedModel);
    }
  } else {
    selectModel(null);
  }
}

renderer.domElement.addEventListener('click', onMouseClick);

function updateObjectList() {
  const container = document.getElementById('objects-container');
  if (!container) return;
  
  if (models.length === 0) {
    container.innerHTML = '<p style="font-size: 11px; color: #666;">No objects loaded</p>';
    return;
  }

  container.innerHTML = '';
  models.forEach((model) => {
    const div = document.createElement('div');
    div.className = 'object-item';
    if (model === selectedModel) {
      div.classList.add('selected');
    }
    
    const boneCount = model.userData.bones ? model.userData.bones.length : 0;
    const boneInfo = boneCount > 0 ? ` (${boneCount} bones)` : '';
    
    // ‚úÖ FIXED - Correct template literal syntax
    div.innerHTML = `
      <span>$${model.userData.name}$$ {boneInfo}</span>
      <button onclick="window.deleteModel(${model.userData.id})" title="Delete">√ó</button>
    `;
    
    div.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON') {
        selectModel(model);
      }
    });
    
    container.appendChild(div);
  });
}

function detectBones(object) {
  const detectedBones = [];
  
  object.traverse((child) => {
    if (child.isBone) {
      detectedBones.push(child);
      child.userData.originalRotation = child.rotation.clone();
      child.userData.originalPosition = child.position.clone();
    }
  });

  object.userData.bones = detectedBones;
  
  if (detectedBones.length > 0) {
    // ‚úÖ FIXED - Correct template literal syntax
    console.log(`Detected $${detectedBones.length} bones in$$ {object.userData.name}`);
  }

  updateBoneList();
}

// ============= BUTTON EVENT LISTENERS =============

const lockBtn = document.getElementById('lock-btn');
if (lockBtn) {
  lockBtn.addEventListener('click', () => {
    if (selectedModel) {
            transformControls.detach();
    }
  });
}

const unlockBtn = document.getElementById('unlock-btn');
if (unlockBtn) {
  unlockBtn.addEventListener('click', () => {
    if (selectedModel) {
      transformControls.attach(selectedModel);
    }
  });
}

const clearBtn = document.getElementById('clear-btn');
if (clearBtn) {
  clearBtn.addEventListener('click', () => {
    if (confirm('Clear all objects from scene?')) {
      models.forEach(model => {
        model.traverse((child) => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (child.material.map) child.material.map.dispose();
            if (child.material.normalMap) child.material.normalMap.dispose();
            if (child.material.roughnessMap) child.material.roughnessMap.dispose();
            if (child.material.metalnessMap) child.material.metalnessMap.dispose();
            child.material.dispose();
          }
        });
        scene.remove(model);
      });
      models.length = 0;
      if (selectedModel) transformControls.detach();
      selectedModel = null;
      selectedBone = null;
      updateObjectList();
      updateBoneList();
      undoManager.clear();
    }
  });
}

const duplicateBtn = document.getElementById('duplicate-btn');
if (duplicateBtn) {
  duplicateBtn.addEventListener('click', () => {
    if (selectedModel) {
      const cloned = selectedModel.clone();
      cloned.position.x += 2;
      modelCounter++;
      cloned.userData = {
        id: modelCounter,
        name: selectedModel.userData.originalName + ' Copy',
        originalName: selectedModel.userData.originalName,
        bones: []
      };
      
      detectBones(cloned);
      
      scene.add(cloned);
      models.push(cloned);
      selectModel(cloned);
      updateObjectList();
      undoManager.pushState();
    }
  });
}

const focusBtn = document.getElementById('focus-btn');
if (focusBtn) {
  focusBtn.addEventListener('click', () => {
    if (selectedModel) {
      const box = new THREE.Box3().setFromObject(selectedModel);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      
      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim * 2;
      
      camera.position.copy(center);
      camera.position.z += distance;
      camera.lookAt(center);
      orbitControls.target.copy(center);
      orbitControls.update();
    }
  });
}

const deleteBtn = document.getElementById('delete-btn');
if (deleteBtn) {
  deleteBtn.addEventListener('click', () => {
    if (selectedModel) {
      window.deleteModel(selectedModel.userData.id);
    }
  });
}

// ============= TRANSFORM MODE BUTTONS =============

const buttons = {
  translate: document.getElementById('translate-btn'),
  rotate: document.getElementById('rotate-btn'),
  scale: document.getElementById('scale-btn')
};

function setActiveButton(activeMode) {
  Object.keys(buttons).forEach(mode => {
    if (buttons[mode]) {
      buttons[mode].classList.toggle('active', mode === activeMode);
    }
  });
}

if (buttons.translate) {
  buttons.translate.addEventListener('click', () => {
    transformControls.setMode('translate');
    setActiveButton('translate');
  });
}

if (buttons.rotate) {
  buttons.rotate.addEventListener('click', () => {
    transformControls.setMode('rotate');
    setActiveButton('rotate');
  });
}

if (buttons.scale) {
  buttons.scale.addEventListener('click', () => {
    transformControls.setMode('scale');
    setActiveButton('scale');
  });
}

// ============= UNDO/REDO BUTTONS =============

const undoBtn = document.getElementById('undo-btn');
if (undoBtn) {
  undoBtn.addEventListener('click', () => {
    if (undoManager.undo()) {
      console.log('Undo successful');
    }
  });
}

const redoBtn = document.getElementById('redo-btn');
if (redoBtn) {
  redoBtn.addEventListener('click', () => {
    if (undoManager.redo()) {
      console.log('Redo successful');
    }
  });
}

// ============= SAVE/LOAD SCENE BUTTONS =============

const saveSceneBtn = document.getElementById('save-scene-btn');
if (saveSceneBtn) {
  saveSceneBtn.addEventListener('click', () => {
    saveSceneToGLB();
  });
}

const loadSceneInput = document.getElementById('load-scene-input');
if (loadSceneInput) {
  loadSceneInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
      loadSceneFromGLB(file);
    }
    event.target.value = '';
  });
}

// ============= KEYBOARD SHORTCUTS =============

document.addEventListener('keydown', (event) => {
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
  
  if (event.ctrlKey || event.metaKey) {
    if (event.key === 'z' || event.key === 'Z') {
      event.preventDefault();
      if (event.shiftKey) {
        undoManager.redo();
      } else {
        undoManager.undo();
      }
      return;
    }
    if (event.key === 'y' || event.key === 'Y') {
      event.preventDefault();
      undoManager.redo();
      return;
    }
    if (event.key === 's' || event.key === 'S') {
      event.preventDefault();
      saveSceneToGLB();
      return;
    }
  }
  
  switch(event.key.toLowerCase()) {
    case 'g':
      transformControls.setMode('translate');
      setActiveButton('translate');
      break;
    case 'r':
      transformControls.setMode('rotate');
      setActiveButton('rotate');
      break;
    case 's':
      if (!event.ctrlKey && !event.metaKey) {
        transformControls.setMode('scale');
        setActiveButton('scale');
      }
      break;
    case 'x':
    case 'delete':
      if (selectedModel) {
        window.deleteModel(selectedModel.userData.id);
      }
      break;
    case 'f':
      if (focusBtn) focusBtn.click();
      break;
    case 'h':
      let allPanelsVisible = true;
      const panels = ['upload-container', 'controls', 'object-list', 'texture-controls', 'bone-controls', 'save-load-controls'];
      
      panels.forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (!panel) return;
        const content = panel.querySelector('.panel-content');
        
        if (content && content.classList.contains('collapsed')) {
          allPanelsVisible = false;
        }
      });
      
      panels.forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (!panel) return;
        const content = panel.querySelector('.panel-content');
        const toggleBtn = panel.querySelector('.toggle-btn');
        
        if (!content || !toggleBtn) return;
        
        if (allPanelsVisible) {
          content.classList.add('collapsed');
          toggleBtn.textContent = '+';
          panel.classList.add('collapsed');
        } else {
          content.classList.remove('collapsed');
          toggleBtn.textContent = '‚àí';
          panel.classList.remove('collapsed');
        }
      });
      break;
    case 'b':
      if (toggleBoneHelpersBtn) toggleBoneHelpersBtn.click();
      break;
    case 'd':
      if (selectedModel && duplicateBtn) {
        duplicateBtn.click();
      }
      break;
    case 'escape':
      selectModel(null);
      selectedBone = null;
      const boneControls = document.getElementById('bone-transform-controls');
      if (boneControls) boneControls.style.display = 'none';
      break;
  }
});


let spikeStyle = 'blades'; // Options: 'blades', 'needles', 'clusters', 'crystals'


// Noise generator (requires SimplexNoise library)


// Note: Make sure to include SimplexNoise library
// <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"

// ============= ENHANCED TERRAIN MODIFICATION SYSTEM =============

let terrainMode = 'hills';
let terrainSettings = {
  height: 2.0,
  density: 5,
  roughness: 0.5,
  groundSize: 200,
  brushSize: 5.0,
  brushStrength: 0.5,
  paintBrushSize: 3.0,
  textureTiling: 10
};
let paintModeEnabled = false;
let texturePaintModeEnabled = false;
let isPainting = false;
let currentPaintTexture = 1;

// Texture painting system
let paintTextures = {
  texture1: null,
  texture2: null,
  texture3: null
};
let splatMap = null;
let terrainMaterial = null;

// Simplex noise for terrain generation
const simplex = new SimplexNoise();

// Set terrain mode
window.setTerrainMode = function(mode) {
  terrainMode = mode;
  
  document.getElementById('hills-mode-btn').classList.remove('active');
  document.getElementById('spikes-mode-btn').classList.remove('active');
  document.getElementById('smooth-mode-btn').classList.remove('active');
  document.getElementById('canyon-mode-btn').classList.remove('active');
  
  document.getElementById(`${mode}-mode-btn`).classList.add('active');
  
  console.log('Terrain mode set to:', mode);
};

// Create enhanced ground plane with subdivisions and texture support
function createTerrainGroundPlane(size = 200, segments = 200) {
  if (groundPlane) {
    scene.remove(groundPlane);
    if (groundPlane.geometry) groundPlane.geometry.dispose();
    if (groundPlane.material) {
      if (groundPlane.material.map) groundPlane.material.map.dispose();
      groundPlane.material.dispose();
    }
  }

  const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
  
  // Create canvas for splat map (texture blending)
  const splatMapSize = 512;
  const canvas = document.createElement('canvas');
  canvas.width = splatMapSize;
  canvas.height = splatMapSize;
  const ctx = canvas.getContext('2d');
  
  // Initialize with red channel (texture 1)
  ctx.fillStyle = 'rgb(255, 0, 0)';
  ctx.fillRect(0, 0, splatMapSize, splatMapSize);
  
  splatMap = new THREE.CanvasTexture(canvas);
  splatMap.needsUpdate = true;
  
  // Create material with texture blending support
  const vertexShader = `
    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vPosition;
    
    void main() {
      vUv = uv;
      vNormal = normalize(normalMatrix * normal);
      vPosition = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;
  
  const fragmentShader = `
    uniform sampler2D splatMap;
    uniform sampler2D texture1;
    uniform sampler2D texture2;
    uniform sampler2D texture3;
    uniform float textureTiling;
    uniform vec3 baseColor;
    
    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vPosition;
    
    void main() {
      // Read splat map
      vec4 splat = texture2D(splatMap, vUv);
      
      // Tiled UVs for textures
      vec2 tiledUv = vUv * textureTiling;
      
      // Sample textures
      vec4 color1 = texture2D(texture1, tiledUv);
      vec4 color2 = texture2D(texture2, tiledUv);
      vec4 color3 = texture2D(texture3, tiledUv);
      
      // Blend textures based on splat map
      vec4 finalColor = color1 * splat.r + color2 * splat.g + color3 * splat.b;
      
      // If no textures loaded, use base color
      if (splat.r + splat.g + splat.b < 0.1) {
        finalColor = vec4(baseColor, 1.0);
      }
      
      // Simple lighting
      vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
      float diff = max(dot(vNormal, lightDir), 0.0);
      finalColor.rgb *= (0.5 + 0.5 * diff);
      
      gl_FragColor = finalColor;
    }
  `;
  
  // Default white textures
  const defaultTexture = new THREE.DataTexture(
    new Uint8Array([255, 255, 255, 255]), 
    1, 1, 
    THREE.RGBAFormat
  );
  defaultTexture.needsUpdate = true;
  
  terrainMaterial = new THREE.ShaderMaterial({
    uniforms: {
      splatMap: { value: splatMap },
      texture1: { value: paintTextures.texture1 || defaultTexture },
      texture2: { value: paintTextures.texture2 || defaultTexture },
      texture3: { value: paintTextures.texture3 || defaultTexture },
      textureTiling: { value: terrainSettings.textureTiling },
      baseColor: { value: new THREE.Color(0x808080) }
    },
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    side: THREE.DoubleSide
  });

  groundPlane = new THREE.Mesh(geometry, terrainMaterial);
  groundPlane.rotation.x = -Math.PI / 2;
  groundPlane.position.y = -1;
  
  groundPlane.receiveShadow = true;
  groundPlane.castShadow = true;
  groundPlane.userData.isGroundPlane = true;
  groundPlane.userData.splatMapCanvas = canvas;
  scene.add(groundPlane);
  
  return groundPlane;
}
// Set spike style
window.setSpikeStyle = function(style) {
  spikeStyle = style;
  terrainSettings.spikeStyle = style;
  
  // Update button states
  document.getElementById('blades-style-btn').classList.remove('active');
  document.getElementById('needles-style-btn').classList.remove('active');
  document.getElementById('clusters-style-btn').classList.remove('active');
  document.getElementById('crystals-style-btn').classList.remove('active');
  
  document.getElementById(`${style}-style-btn`).classList.add('active');
  
  console.log('Spike style set to:', style);
  
  // Auto-apply if in spikes mode
  if (terrainMode === 'spikes' && groundPlane) {
    applyTerrain();
  }
};

// Apply terrain modifications
window.applyTerrain = function() {
  const size = terrainSettings.groundSize;
  const segments = Math.max(100, Math.min(300, Math.floor(size * 0.5)));
  
  if (!groundPlane || !terrainMaterial) {
    createTerrainGroundPlane(size, segments);
  } else {
    // Update size if needed
    const currentSize = groundPlane.geometry.parameters.width;
    if (Math.abs(currentSize - size) > 1) {
      createTerrainGroundPlane(size, segments);
    }
  }
  
  const geometry = groundPlane.geometry;
  const positionAttribute = geometry.attributes.position;
  const vertex = new THREE.Vector3();
  
  for (let i = 0; i < positionAttribute.count; i++) {
    vertex.fromBufferAttribute(positionAttribute, i);
    
    const x = vertex.x;
    const y = vertex.y;
    
    let z = 0;
    
    switch(terrainMode) {
      case 'hills':
        z = simplex.noise2D(x * 0.1 / terrainSettings.density, y * 0.1 / terrainSettings.density) * terrainSettings.height;
        z += simplex.noise2D(x * 0.05 / terrainSettings.density, y * 0.05 / terrainSettings.density) * terrainSettings.height * 0.5;
        z += simplex.noise2D(x * 0.2 / terrainSettings.density, y * 0.2 / terrainSettings.density) * terrainSettings.height * 0.25;
        break;
case 'spikes':
  // Hair particle system - different spike styles
  switch(spikeStyle) {
    case 'blades':
      // Thin grass blade hair particles
      const grassFreq = 3.0 / terrainSettings.density;
      
      const particleX = Math.floor(x * grassFreq);
      const particleY = Math.floor(y * grassFreq);
      
      let maxBladeHeight = 0;
      
      // Check surrounding cells for hair particles
      for(let px = -1; px <= 1; px++) {
        for(let py = -1; py <= 1; py++) {
          const cellX = particleX + px;
          const cellY = particleY + py;
          
          // Number of hair strands per cell (2-5)
          const hairCount = Math.floor((simplex.noise2D(cellX * 3.14, cellY * 6.28) + 1) * 1.5 + 2);
          
          // Generate multiple hair particles per cell
          for(let h = 0; h < hairCount; h++) {
            // Unique position for each hair strand
            const particlePosX = (simplex.noise2D(cellX * 12.34 + h * 7.89, cellY * 56.78) + 1) * 0.5;
            const particlePosY = (simplex.noise2D(cellX * 78.90, cellY * 34.56 + h * 9.87) + 1) * 0.5;
            
            const worldX = cellX + particlePosX;
            const worldY = cellY + particlePosY;
            
            // Distance from current point to hair root
            const dx = (x * grassFreq) - worldX;
            const dy = (y * grassFreq) - worldY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Hair strand thickness (very thin)
            const hairThickness = 0.02 + terrainSettings.roughness * 0.015;
            
            if(dist < hairThickness) {
              // Hair strand profile with tapering
              const falloff = 1.0 - (dist / hairThickness);
              const taper = Math.pow(falloff, 3.0); // Thin profile
              
              // Individual hair height with variation
              const hairSeed = simplex.noise2D(cellX * 0.5 + h * 2.1, cellY * 0.5 + h * 3.7);
              const hairLength = 0.6 + hairSeed * 0.7; // Vary length per hair
              
              // Calculate height along hair strand
              const hairHeight = taper * terrainSettings.height * 3.5 * hairLength;
              
              maxBladeHeight = Math.max(maxBladeHeight, hairHeight);
            }
          }
        }
      }
      
      z = maxBladeHeight;
      
      // Subtle ground
      z += simplex.noise2D(x * 0.5, y * 0.5) * terrainSettings.height * 0.05;
      break;
      
    case 'needles':
      // Sharp needle hair particles (like porcupine quills)
      const needleFreq = 2.0 / terrainSettings.density;
      
      const needleX = Math.floor(x * needleFreq);
      const needleY = Math.floor(y * needleFreq);
      
      let maxNeedleHeight = 0;
      
      for(let px = -1; px <= 1; px++) {
        for(let py = -1; py <= 1; py++) {
          const cellX = needleX + px;
          const cellY = needleY + py;
          
          // Fewer, sparser needle hairs
          const needleCount = Math.floor((simplex.noise2D(cellX * 2.71, cellY * 8.28) + 1) * 1.0 + 1);
          
          for(let h = 0; h < needleCount; h++) {
            const particlePosX = (simplex.noise2D(cellX * 23.45 + h * 5.43, cellY * 67.89) + 1) * 0.5;
            const particlePosY = (simplex.noise2D(cellX * 89.01, cellY * 45.67 + h * 8.21) + 1) * 0.5;
            
            const worldX = cellX + particlePosX;
            const worldY = cellY + particlePosY;
            
            const dx = (x * needleFreq) - worldX;
            const dy = (y * needleFreq) - worldY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Very thin needle hair
            const needleThickness = 0.025;
            
            // Spawn probability for sparse distribution
            const spawnChance = (simplex.noise2D(cellX * 0.3 + h, cellY * 0.3 + h) + 1) * 0.5;
            
            if(dist < needleThickness && spawnChance > 0.35) {
              const falloff = 1.0 - (dist / needleThickness);
              const sharpnessFactor = Math.pow(terrainSettings.roughness, 0.3);
              const needleTaper = Math.pow(falloff, 4.0 - sharpnessFactor * 2); // Very sharp taper
              
              // Individual needle length
              const needleSeed = simplex.noise2D(cellX * 0.7 + h * 1.9, cellY * 0.7 + h * 2.3);
              const needleLength = 0.5 + needleSeed * 0.9;
              
              const needleHeight = needleTaper * terrainSettings.height * 4.0 * needleLength;
              
              maxNeedleHeight = Math.max(maxNeedleHeight, needleHeight);
            }
          }
        }
      }
      
      z = maxNeedleHeight;
      
      // Minimal ground
      z += simplex.noise2D(x * needleFreq * 0.5, y * needleFreq * 0.5) * terrainSettings.height * 0.05;
      break;
      
    case 'clusters':
      // Clustered hair tufts (like fur clumps)
      const clusterFreq = 1.5 / terrainSettings.density;
      
      const clusterX = Math.floor(x * clusterFreq);
      const clusterY = Math.floor(y * clusterFreq);
      
      let maxClusterHeight = 0;
      
      for(let px = -1; px <= 1; px++) {
        for(let py = -1; py <= 1; py++) {
          const cellX = clusterX + px;
          const cellY = clusterY + py;
          
          // Cluster center
          const clusterPosX = (simplex.noise2D(cellX * 34.56, cellY * 78.90) + 1) * 0.5;
          const clusterPosY = (simplex.noise2D(cellX * 90.12, cellY * 56.34) + 1) * 0.5;
          
          const clusterWorldX = cellX + clusterPosX;
          const clusterWorldY = cellY + clusterPosY;
          
          const distToCluster = Math.sqrt(
            Math.pow((x * clusterFreq) - clusterWorldX, 2) + 
            Math.pow((y * clusterFreq) - clusterWorldY, 2)
          );
          
          const clusterRadius = 0.35;
          
          // Only generate hairs within cluster radius
          if(distToCluster < clusterRadius) {
            // Dense hair count within cluster
            const hairsInCluster = Math.floor((simplex.noise2D(cellX * 4.56, cellY * 7.89) + 1) * 3 + 4);
            
            for(let h = 0; h < hairsInCluster; h++) {
              // Hair position relative to cluster center
              const hairOffsetX = (simplex.noise2D(cellX * 11.11 + h * 3.33, cellY * 22.22) - 0.5) * clusterRadius * 0.8;
              const hairOffsetY = (simplex.noise2D(cellX * 33.33, cellY * 44.44 + h * 5.55) - 0.5) * clusterRadius * 0.8;
              
              const hairWorldX = clusterWorldX + hairOffsetX;
              const hairWorldY = clusterWorldY + hairOffsetY;
              
              const dx = (x * clusterFreq) - hairWorldX;
              const dy = (y * clusterFreq) - hairWorldY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              const hairThickness = 0.03;
              
              if(dist < hairThickness) {
                const falloff = 1.0 - (dist / hairThickness);
                const hairTaper = Math.pow(falloff, 2.5 - terrainSettings.roughness);
                
                // Hairs in center of cluster are taller
                const clusterFalloff = 1.0 - (distToCluster / clusterRadius);
                const hairLength = 0.7 + clusterFalloff * 0.5;
                
                const hairHeight = hairTaper * terrainSettings.height * 2.8 * hairLength;
                maxClusterHeight = Math.max(maxClusterHeight, hairHeight);
              }
            }
          }
        }
      }
      
      z = maxClusterHeight;
      
      // Ground between clusters
      z += simplex.noise2D(x * 0.3, y * 0.3) * terrainSettings.height * 0.03;
      break;
      
    case 'crystals':
      // Crystal spike hair particles (rigid, angular)
      const crystalFreq = 2.5 / terrainSettings.density;
      
      const crystalX = Math.floor(x * crystalFreq);
      const crystalY = Math.floor(y * crystalFreq);
      
      let maxCrystalHeight = 0;
      
      for(let px = -1; px <= 1; px++) {
        for(let py = -1; py <= 1; py++) {
          const cellX = crystalX + px;
          const cellY = crystalY + py;
          
          // Sparse crystal spikes
          const crystalCount = Math.floor((simplex.noise2D(cellX * 5.67, cellY * 9.01) + 1) * 0.8 + 1);
          
          for(let h = 0; h < crystalCount; h++) {
            const particlePosX = (simplex.noise2D(cellX * 45.67 + h * 6.78, cellY * 89.01) + 1) * 0.5;
            const particlePosY = (simplex.noise2D(cellX * 11.23, cellY * 67.89 + h * 4.56) + 1) * 0.5;
            
            const worldX = cellX + particlePosX;
            const worldY = cellY + particlePosY;
            
            const dx = (x * crystalFreq) - worldX;
            const dy = (y * crystalFreq) - worldY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            const crystalThickness = 0.08; // Thicker than other hairs
            
            // Spawn probability
            const spawnChance = (simplex.noise2D(cellX * 0.5 + h * 1.7, cellY * 0.5 + h * 2.3) + 1) * 0.5;
            
            if(dist < crystalThickness && spawnChance > 0.4) {
              const falloff = 1.0 - (dist / crystalThickness);
              
              // Angular, faceted profile (less smooth taper)
              const angle = Math.atan2(dy, dx);
              const facets = 6; // Hexagonal crystal
              const facetAngle = Math.floor(angle / (Math.PI * 2 / facets)) * (Math.PI * 2 / facets);
              const facetDist = dist * (1.0 + Math.cos((angle - facetAngle) * facets) * 0.1);
              
              const facetedFalloff = 1.0 - (facetDist / crystalThickness);
              const crystalTaper = Math.pow(Math.max(0, facetedFalloff), 1.8 - terrainSettings.roughness * 0.8);
              
              // Individual crystal height
              const crystalLength = 0.7 + spawnChance * 0.6;
              const crystalHeight = crystalTaper * terrainSettings.height * 4.5 * crystalLength;
              
              maxCrystalHeight = Math.max(maxCrystalHeight, crystalHeight);
            }
          }
        }
      }
      
      z = maxCrystalHeight;
      
      // Flat ground
      z += simplex.noise2D(x * 0.2, y * 0.2) * terrainSettings.height * 0.08;
      break;
  }
  break;

        
      case 'smooth':
        z = simplex.noise2D(x * 0.05 / terrainSettings.density, y * 0.05 / terrainSettings.density) * terrainSettings.height * 0.5;
        break;
        
      case 'canyon':
        const canyonNoise = simplex.noise2D(x * 0.15 / terrainSettings.density, y * 0.15 / terrainSettings.density);
        z = -Math.abs(canyonNoise) * terrainSettings.height;
        z += simplex.noise2D(x * 0.3 / terrainSettings.density, y * 0.3 / terrainSettings.density) * terrainSettings.height * 0.3;
        break;
    }
    
    positionAttribute.setZ(i, z);
  }
  
  positionAttribute.needsUpdate = true;
  geometry.computeVertexNormals();
  
  console.log(`Applied ${terrainMode} terrain (size: ${size})`);
  undoManager.pushState();
};

// Reset terrain to flat
window.resetTerrain = function() {
  if (!groundPlane) {
    createTerrainGroundPlane();
    return;
  }
  
  const geometry = groundPlane.geometry;
  const positionAttribute = geometry.attributes.position;
  
  for (let i = 0; i < positionAttribute.count; i++) {
    positionAttribute.setZ(i, 0);
  }
  
  positionAttribute.needsUpdate = true;
  geometry.computeVertexNormals();
  
  console.log('Terrain reset to flat');
  undoManager.pushState();
};

// Toggle sculpt mode
window.togglePaintMode = function() {
  paintModeEnabled = !paintModeEnabled;
  
  if (paintModeEnabled && texturePaintModeEnabled) {
    toggleTexturePaintMode(); // Disable texture paint
  }
  
  const btn = document.getElementById('toggle-paint-mode-btn');
  if (paintModeEnabled) {
    btn.textContent = 'Disable Sculpt Mode';
    btn.classList.add('active');
    orbitControls.enabled = false;
    transformControls.enabled = false;
    console.log('Sculpt mode enabled');
  } else {
    btn.textContent = 'Enable Sculpt Mode';
    btn.classList.remove('active');
    orbitControls.enabled = true;
    transformControls.enabled = true;
    console.log('Sculpt mode disabled');
  }
};

// Toggle texture paint mode
window.toggleTexturePaintMode = function() {
  texturePaintModeEnabled = !texturePaintModeEnabled;
  
  if (texturePaintModeEnabled && paintModeEnabled) {
    togglePaintMode(); // Disable sculpt mode
  }
  
  const btn = document.getElementById('toggle-texture-paint-btn');
  if (texturePaintModeEnabled) {
    btn.textContent = 'Disable Texture Paint';
    btn.classList.add('active');
    orbitControls.enabled = false;
    transformControls.enabled = false;
    
    if (!groundPlane || !terrainMaterial) {
      createTerrainGroundPlane();
    }
    
    console.log('Texture paint mode enabled');
  } else {
    btn.textContent = 'Enable Texture Paint';
    btn.classList.remove('active');
    orbitControls.enabled = true;
    transformControls.enabled = true;
    console.log('Texture paint mode disabled');
  }
};

// Select paint texture
window.selectPaintTexture = function(textureNum) {
  currentPaintTexture = textureNum;
  
  document.getElementById('texture-1-btn').classList.remove('active');
  document.getElementById('texture-2-btn').classList.remove('active');
  document.getElementById('texture-3-btn').classList.remove('active');
  
  document.getElementById(`texture-${textureNum}-btn`).classList.add('active');
  
  console.log(`Selected texture ${textureNum} for painting`);
};

// Paint texture on terrain
function paintTextureOnTerrain(intersectionPoint) {
  if (!groundPlane || !texturePaintModeEnabled || !groundPlane.userData.splatMapCanvas) return;
  
  const canvas = groundPlane.userData.splatMapCanvas;
  const ctx = canvas.getContext('2d');
  
  // Convert world position to UV coordinates
  const size = groundPlane.geometry.parameters.width;
  const localX = intersectionPoint.x - groundPlane.position.x;
  const localZ = intersectionPoint.z - groundPlane.position.z;
  
  const u = (localX / size + 0.5) * canvas.width;
  const v = (1 - (localZ / size + 0.5)) * canvas.height;
  
  const brushRadius = terrainSettings.paintBrushSize * (canvas.width / size);
  
  // Create gradient brush
  const gradient = ctx.createRadialGradient(u, v, 0, u, v, brushRadius);
  
  // Set color based on selected texture
  let color;
  switch(currentPaintTexture) {
    case 1:
      color = 'rgba(255, 0, 0, 0.3)';
      break;
    case 2:
      color = 'rgba(0, 255, 0, 0.3)';
      break;
    case 3:
      color = 'rgba(0, 0, 255, 0.3)';
      break;
  }
  
  gradient.addColorStop(0, color);
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  
  // Use source-over for blending
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = gradient;
  
  // Begin path and draw circle (more accurate than fillRect)
  ctx.beginPath();
  ctx.arc(u, v, brushRadius, 0, Math.PI * 1);
  ctx.fill();
  
  splatMap.needsUpdate = true;
}

// Sculpt terrain on mouse interaction
function sculptTerrain(intersectionPoint) {
  if (!groundPlane || !paintModeEnabled) return;
  
  const geometry = groundPlane.geometry;
  const positionAttribute = geometry.attributes.position;
  const vertex = new THREE.Vector3();
  
  const brushRadius = terrainSettings.brushSize;
  const brushStrength = terrainSettings.brushStrength;
  
  for (let i = 0; i < positionAttribute.count; i++) {
    vertex.fromBufferAttribute(positionAttribute, i);
    
    const worldVertex = vertex.clone();
    worldVertex.applyMatrix4(groundPlane.matrixWorld);
    
    const distance = worldVertex.distanceTo(intersectionPoint);
    
    if (distance < brushRadius) {
      const influence = 1 - (distance / brushRadius);
      const heightChange = influence * brushStrength * 0.1;
      
      let currentZ = positionAttribute.getZ(i);
      
      switch(terrainMode) {
        case 'hills':
          currentZ += heightChange;
          break;
        case 'spikes':
          currentZ += heightChange * 2;
          break;
        case 'smooth':
          const neighbors = [];
          for (let j = Math.max(0, i - 10); j < Math.min(positionAttribute.count, i + 10); j++) {
            neighbors.push(positionAttribute.getZ(j));
          }
          const avg = neighbors.reduce((a, b) => a + b, 0) / neighbors.length;
          currentZ = THREE.MathUtils.lerp(currentZ, avg, influence * 0.5);
          break;
        case 'canyon':
          currentZ -= Math.abs(heightChange);
          break;
      }
      
      positionAttribute.setZ(i, currentZ);
    }
  }
  
  positionAttribute.needsUpdate = true;
  geometry.computeVertexNormals();
}

// Mouse events for painting
renderer.domElement.addEventListener('mousedown', (event) => {
  if (!paintModeEnabled && !texturePaintModeEnabled) return;
  
  isPainting = true;
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(groundPlane);
  
  if (intersects.length > 0) {
    if (paintModeEnabled) {
      sculptTerrain(intersects[0].point);
    } else if (texturePaintModeEnabled) {
      paintTextureOnTerrain(intersects[0].point);
    }
  }
});

renderer.domElement.addEventListener('mousemove', (event) => {
  if (!isPainting) return;
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(groundPlane);
  
  if (intersects.length > 0) {
    if (paintModeEnabled) {
      sculptTerrain(intersects[0].point);
    } else if (texturePaintModeEnabled) {
      paintTextureOnTerrain(intersects[0].point);
    }
  }
});

renderer.domElement.addEventListener('mouseup', () => {
  if (isPainting) {
    isPainting = false;
    undoManager.pushState();
  }
});

// Load paint textures
function loadPaintTexture(file, textureNum) {
  if (!file.type.startsWith('image/')) {
    alert('Please select an image file');
    return;
  }
  
  const textureLoader = new THREE.TextureLoader();
  textureLoader.load(URL.createObjectURL(file), (texture) => {
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    texture.encoding = THREE.sRGBEncoding;
    
    // Store texture
    paintTextures[`texture${textureNum}`] = texture;
    
    // Update material if it exists
    if (terrainMaterial) {
      terrainMaterial.uniforms[`texture${textureNum}`].value = texture;
      terrainMaterial.needsUpdate = true;
    }
    
    // Update preview
    const preview = document.getElementById(`preview-${textureNum}`);
    if (preview) {
      preview.style.background = `url(${URL.createObjectURL(file)})`;
      preview.style.backgroundSize = 'cover';
    }
    
    console.log(`Loaded texture ${textureNum}:`, file.name);
  });
}

document.getElementById('paint-texture-1-input').addEventListener('change', (e) => {
  if (e.target.files[0]) loadPaintTexture(e.target.files[0], 1);
  e.target.value = '';
});

document.getElementById('paint-texture-2-input').addEventListener('change', (e) => {
  if (e.target.files[0]) loadPaintTexture(e.target.files[0], 2);
  e.target.value = '';
});

document.getElementById('paint-texture-3-input').addEventListener('change', (e) => {
  if (e.target.files[0]) loadPaintTexture(e.target.files[0], 3);
  e.target.value = '';
});

// Terrain settings sliders
document.getElementById('terrain-height-slider').addEventListener('input', (e) => {
  terrainSettings.height = parseFloat(e.target.value);
  document.getElementById('terrain-height-value').textContent = terrainSettings.height.toFixed(1);
});

document.getElementById('terrain-density-slider').addEventListener('input', (e) => {
  terrainSettings.density = parseFloat(e.target.value);
  document.getElementById('terrain-density-value').textContent = terrainSettings.density;
});

document.getElementById('terrain-roughness-slider').addEventListener('input', (e) => {
  terrainSettings.roughness = parseFloat(e.target.value);
  document.getElementById('terrain-roughness-value').textContent = terrainSettings.roughness.toFixed(1);
});

document.getElementById('ground-size-slider').addEventListener('input', (e) => {
  terrainSettings.groundSize = parseFloat(e.target.value);
  document.getElementById('ground-size-value').textContent = terrainSettings.groundSize;
});

document.getElementById('brush-size-slider').addEventListener('input', (e) => {
  terrainSettings.brushSize = parseFloat(e.target.value);
  document.getElementById('brush-size-value').textContent = terrainSettings.brushSize.toFixed(1);
});

document.getElementById('brush-strength-slider').addEventListener('input', (e) => {
  terrainSettings.brushStrength = parseFloat(e.target.value);
  document.getElementById('brush-strength-value').textContent = terrainSettings.brushStrength.toFixed(1);
});

document.getElementById('paint-brush-size-slider').addEventListener('input', (e) => {
  terrainSettings.paintBrushSize = parseFloat(e.target.value);
  document.getElementById('paint-brush-size-value').textContent = terrainSettings.paintBrushSize.toFixed(1);
});

document.getElementById('texture-tiling-slider').addEventListener('input', (e) => {
  terrainSettings.textureTiling = parseFloat(e.target.value);
  document.getElementById('texture-tiling-value').textContent = terrainSettings.textureTiling;
  
  if (terrainMaterial) {
    terrainMaterial.uniforms.textureTiling.value = terrainSettings.textureTiling;
  }
});

// Initialize terrain mode
setTerrainMode('hills');

console.log('Enhanced terrain system initialized with texture painting');



// ============= ANIMATION LOOP =============
function animate() {
  requestAnimationFrame(animate);
  
  orbitControls.update();
  animateHairWind(); // Add this line
    // Update bone visualizations
  updateBoneVisualHelpers();
  renderer.render(scene, camera);
}

animate();

// ============= WINDOW RESIZE =============

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============= MAKE FUNCTIONS GLOBAL =============

window.scene = scene;
window.camera = camera;
window.renderer = renderer;
window.models = models;
window.texturePlanes = texturePlanes;
window.selectedModel = selectedModel;
window.selectModel = selectModel;
window.updateObjectList = updateObjectList;
window.updateTexturePlaneList = updateTexturePlaneList;
window.updateBoneList = updateBoneList;
window.groundPlane = groundPlane;
window.skySphere = skySphere;
window.createGroundPlane = createGroundPlane;
window.createSkySphere = createSkySphere;
window.saveSceneToGLB = saveSceneToGLB;
window.loadSceneFromGLB = loadSceneFromGLB;

// ============= INITIALIZE =============
// At the very end of your script, after all other code:


updateObjectList();
updateBoneList();
undoManager.updateButtons();
animate();

console.log('COOKuP 3D Editor initialized with GLB support');
console.log('');
console.log('‚ú® KEYBOARD SHORTCUTS:');
console.log('  G - Move mode');
console.log('  R - Rotate mode');
console.log('  S - Scale mode');
console.log('  F - Focus on selected');
console.log('  X/Delete - Delete selected');
console.log('  D - Duplicate selected');
console.log('  H - Toggle all panels');
console.log('  B - Toggle bone helpers');
console.log('  Ctrl+Z - Undo');
console.log('  Ctrl+Y or Ctrl+Shift+Z - Redo');
console.log('  Ctrl+S - Save scene as GLB');
console.log('  Escape - Deselect');
console.log('');
console.log('üíæ GLB Save/Load:');
console.log('  ‚Ä¢ Saves all models, textures, and transforms');
console.log('  ‚Ä¢ Preserves ground plane and sky sphere');
console.log('  ‚Ä¢ Includes texture planes');
console.log('  ‚Ä¢ Mobile share support enabled');

</script>

</body>
</html>


